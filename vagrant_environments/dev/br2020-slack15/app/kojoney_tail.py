#!/usr/bin/python 

import time, os , syslog , urlparse , re 
import twitter		# Google API

import ipintellib	# RCH library - master on mars
import mailalert	# RCH library
import p0fcmd		# RCH library - master on mars
#import rch_asn_funcs	# RCH library - master on mars
import playAlert	# master on mars
import getSnortInfo	# RCH code - not a module
import kojoney_funcs

# Globals
PreviousIPs = {}
CLInum=0		# number of lines of CLI processed
Version="1.2"		# added p0f v 3.0.0
TweetVersion="0.2"	# update if Tweet format changes
SessionId=-1		# incremented for every authenticated (authOK) session
Username = "_unknown_"	# Uninitialised

ROUTER = "172.31.0.9"
HPOT   = "172.31.0.67"  # High-interaction honeypot
MWARE  = "192.168.1.66" # Botwall Malware Collector : Amun
HONEYD = "172.31.0.1"

#IBG    = "172.31.0.47"	# IP address sending netflow 
IBG    = "192.168.1.7"	# IP address sending netflow 

# need this so program can be monitored by monit
# make this a library function
def makePidFile(name):
    pid = os.getpid()
    
    pidFilename = "/var/run/rchpids/" + name + ".pid"
    fp=open(pidFilename,'w')
    print >> fp,pid
    fp.close()            
    #print "pid is " + `pid`
    return pid	# returns None if failed


# do this with a regex !!!
def isValidHex(a):
    
    if a[0] == '0' and a[1] == '0' :
        return True
    
    if a[0] == 'a' or a[0] == 'b' or a[0] == 'c' or a[0]=='d' or a[0]=='e' or a[0]=='f' or a[0]=='0' or a[0]=='1' or a[0]=='2' or a[0]=='3' or a[0]=='4' or a[0]=='5' or a[0]=='6' or a[0]=='7' or a[0]=='8' or a[0]=='9':
        if a[1] == 'a' or a[1] == 'b' or a[1] == 'c' or a[1]=='d' or a[1]=='e' or a[1]=='f' or a[1]=='0' or a[1]=='1' or a[1]=='2' or a[1]=='3' or a[1]=='4' or a[1]=='5' or a[1]=='6' or a[1]=='7' or a[1]=='8' or a[1]=='9':
            return True
    return False
                                        
# print Flexible Netflow Section payload as ASCII
def decodeSection(payload):    
    
    if payload.find("none") != -1:
        print "found 'none' in payload"
        return "***NONE***"
    
    x = len(payload)
    #x = 24
    #print "bytes of payload to decode : " + `x`
    
    r=""
    for i in range(0,x,2):
        a = payload[i] + payload[i+1]
        if isValidHex(a) == False: 
            return "***DECODING_ERROR***"	# bug !!! : this does not fix the problem !!!
        ch = int(a,16)  			# ch is a number
        #print "i=" + `i` + " " + `ch`
        b = chr(ch)
        #print "b is " + `b` + " ch is " + `ch` 
        #if b.isalnum() or (b >= 32 and b < 127):
        if (ch >= 32 and ch < 127) : # is it printable ?
            r = r + b
            #print "printable : " + b
        else:
            #r = r + "."
            r = r + " "
                                                                                                
    #print "result is " + r
    return r

# Send an e-mail
def alert(subject,ip,username,content):
    smtpServer   = 'smtp.btconnect.com'
    sender       = 'the.crouches@btconnect.com'
    destination  = ['richard.crouch@vodafone.com']
    debugLevel   = False
    
    try:
    
        now = time.time()
        #nowLocal = time.gmtime(now)
        nowLocal = time.localtime(now)

        # Get DNS info
        dnsInfo = ipintellib.ip2name(ip)
        dnsName = dnsInfo['name']
        
        # WHOIS information
        #asInfo = rch_asn_funcs.ip2asn(ip)
        asInfo = ipintellib.ip2asn(ip)
        #asNum = asInfo['as']					# AS123 
        asRegisteredCode = asInfo['registeredCode']		# Short-form e.g.ARCOR
        
        # GeoIP information
        geoIP = ipintellib.geo_ip(ip)
        countryCode = geoIP['countryCode']
        city        = geoIP['city']
        longitude   = geoIP['longitude']			# Calc approx. localtime
        latitude    = geoIP['latitude']    
                    
        info = "haxx0r IP : " + ip + "\nuser : " + username + "\nDNS : " + dnsName + "\n\n" + "AS Name : " + asRegisteredCode + "\n\nGeoIP Country : " + countryCode + "\nGeoIP City : " + "\nGeoIP Longitude : " + "%.2f" % longitude + "\nGeoIP Latitude : " + "%.2f" % latitude 
   
        # Haxx0r's client stack information
        p0fInfo = p0fcmd.getP0fInfo(ip,"0","172.31.0.67","22");
        if p0fInfo['result'] == True:
             p0fStr = "os=" + p0fInfo['genre'] + " hops=" + p0fInfo['hops'] + " linktype=" + p0fInfo['linktype'] + " up_secs=" + p0fInfo['uptime'] + " tos=" + p0fInfo['tos'] + " masq=" + p0fInfo['masq'] + " fw=" + p0fInfo['firewall'] + " NAT=" + p0fInfo['nat'] + " realOS=" + p0fInfo['realos']
        else:
             p0fStr = p0fInfo['errormsg']
   
        # Notify !
        alertSubject = "honeypot intrusion! : " + subject
        alertContent = info + "\n\np0f : " + p0fStr + "\n\n" + content + "\n\nThis e-mail was automatically generated by the DarkRain Honeypot System on " + time.asctime(nowLocal) + "\n\n"                 
        
        print "alert():\nsubject:" + alertSubject + "\ncontent:\n" + alertContent + "\n" 
        
        status = mailalert.mailalert(sender,destination,smtpServer,alertSubject,alertContent,debugLevel)
        
        # uncomment the following line if you want to see the e-mail being sent
        print "notify     : e-mail : subject=" + '"' + alertSubject + '"'
        
        # Add a record to syslog
        a = "Sent alert e-mail, Subject=" + alertSubject + " to " + destination[0]
        syslog.syslog(a)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : alert() : " + `e` + " ip=" + ip)

def statusAlert(subject,content):
    smtpServer   = 'smtp.btconnect.com'
    sender       = 'the.crouches@btconnect.com'
    destination  = ['richard.crouch@vodafone.com']
    debugLevel   = False
    
    try:        
        now = time.time()
        nowLocal = time.localtime(now)

        # Notify !
        alertSubject = "DarkRain : " + subject
        #alertSubject = "honeypot status : " + subject
        alertContent = content + "\n\nThis e-mail was automatically generated by the DarkRain Honeypot System on " + time.asctime(nowLocal) + "\n\n"                 
        
        #print "alert subject:" + alertSubject + "\nalertContent:\n" + content + "\n"
        
        status = mailalert.mailalert(sender,destination,smtpServer,alertSubject,alertContent,debugLevel)        
        
        # uncomment the following line if you want to see the e-mail being sent
        print "notify     : e-mail : subject=" + '"' + alertSubject + '"'  
        
        # Add a record to syslog
        a = "Sent alert e-mail, Subject=" + alertSubject + " to " + destination[0]
        syslog.syslog(a)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : statusAlert() : " + `e`)

# Write netflow record to file easily parsable by SEC
# Format IP_address,commandStr
# Need to touch this file

def writeFlow2SEC(line):
    
    try:          
        # Get current time (GMT)
        nowGMT = time.gmtime(time.time())
            
        #msg = time.asctime(nowGMT) + "," + ip + "," + dnsName + "," + countryCode + "," + '"' + filename + '"'
                        
        # Write to file
        fpOut = open(r'/home/var/log/kojoney_sec_flows.csv','a')
        #msg = ip + ":" + asNum + ":" + asRegisteredCode + ":" + p0fStr + "," + username + "," + fileName + "," + countryCode
        msg = line
        #print "writeFlow2SEC():" + msg
        print >> fpOut,msg
        fpOut.close()

    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeFlow2SEC() exception caught = " + `e`)

# Write Security Visualisation data to be processed by AfterGlow to .csv file
# Format : IP_address,commandStr
# Need to touch this file
# TODO : add boot time epoch hours to output file as a way of tracking commands entered by a single haxx0r
# This file can be parsed by awk scripts to format it suitable for visualisation

def writeSecViz1(ip,username,countryCode,commandStr):
    try:    
        #p0fInfo = p0fcmd.getP0fInfo(ip,"0","172.31.0.67","22");
        #if p0fInfo['result'] == True:
        #    p0fStr = "os:" + p0fInfo['genre'] + ":hops=" + p0fInfo['hops'] 
        #else:
        #    p0fStr = p0fInfo['errormsg']
        
        #raise Exception	# test code
        #print i		# force exception for testing
        
        #asInfo = rch_asn_funcs.ip2asn(ip)
        #asNum = asInfo['as']				        # AS123 
        #asRegisteredCode = asInfo['registeredCode']		# Short-form e.g.ARCOR
        
        # Get DNS info
        dnsInfo = ipintellib.ip2name(ip)
        dnsName = dnsInfo['name']
        
        # Get current time (GMT)
        nowGMT = time.gmtime(time.time())
        
        #msg = ip + ":" + asNum + ":" + asRegisteredCode + ":" + p0fStr + "," + username + "," + '"' + commandStr + '"' + "," + countryCode  
        msg = time.asctime(nowGMT) + "," + ip + "," + dnsName + "," + countryCode + "," + username + "," + '"' + commandStr + '"' 
        
        # Write to file
        fpOut = open(r'/home/var/log/kojoney_tail_secviz_cmds.csv','a')
        print "writeSecViz1():" + msg
        print >> fpOut,msg
        fpOut.close()
        
    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeSecViz1() exception caught = " + `e` + " ip=" + ip)

# Write Security Visualisation data to be processed by AfterGlow to .csv file
# Format IP_address,commandStr
# Need to touch this file
# This file can be parsed by awk scripts to format it suitable for visualisation

def writeSecViz2(ip,username,countryCode,fileName):
    try:    
        #p0fInfo = p0fcmd.getP0fInfo(ip,"0","172.31.0.67","22");
        #if p0fInfo['result'] == True:
        #    p0fStr = "os:" + p0fInfo['genre'] + ":hops=" + p0fInfo['hops'] 
        #else:
        #    p0fStr = p0fInfo['errormsg']
        #
        #    asInfo = rch_asn_funcs.ip2asn(ip)
        #    asNum = asInfo['as']					# AS123 
        #    asRegisteredCode = asInfo['registeredCode']		# Short-form e.g.ARCOR
            
        # Get DNS info
        dnsInfo = ipintellib.ip2name(ip)
        dnsName = dnsInfo['name']
          
        # Get current time (GMT)
        nowGMT = time.gmtime(time.time())
            
        msg = time.asctime(nowGMT) + "," + ip + "," + dnsName + "," + countryCode + "," + '"' + filename + '"'
                        
        # Write to file
        fpOut = open(r'/home/var/log/kojoney_tail_secviz_dloads.csv','a')
        #msg = ip + ":" + asNum + ":" + asRegisteredCode + ":" + p0fStr + "," + username + "," + fileName + "," + countryCode
        print "writeSecViz2():" + msg
        print >> fpOut,msg
        fpOut.close()

    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeSecViz2() exception caught = " + `e` + " ip=" + ip)

# Write Security Visualisation data to be processed by AfterGlow to .csv file
# This file is used for correlating haxx0r IP stack uptime with username and src IP
# Need to touch this file
# add hops ?
def writeSecViz3(ip,username):

    #print "entered writeSecViz3()"
    now = time.time()
    
    try:    
        p0fInfo = p0fcmd.getP0fInfo(ip,"0","172.31.0.67","22");
        if p0fInfo['result'] == True :		# p0f data is available
            hops = p0fInfo['hops']
            os   = p0fInfo['genre']
            fw   = p0fInfo['firewall']
            nat  = p0fInfo['nat'] 
            if p0fInfo['genre'] == "Linux" :
                uptime = p0fInfo['uptime'] 
                bte = now - int(uptime)
                hops = p0fInfo['hops']    
            else:
                uptimeHours = 0
                bte = 0
        else:					# p0f data not read OK
            hops = 0        
            os   = "?"
            fw   = "?"
            nat  = "?"
            bte  = 0
              
        # get current time
        timeTuple = time.localtime(now)
        nowStr    = time.asctime(timeTuple)
            
        # calc haxx0r bootTime 	
        timeTuple   = time.localtime(bte)
        bootTimeStr = time.asctime(timeTuple)
        bootTimeEpochHours = int(bte/3600)
        #print "bootTimeEpochHours:" + `bootTimeEpochHours`
        
        #asInfo = rch_asn_funcs.ip2asn(ip)
        asInfo = ipintellib.ip2asn(ip)
        #asNum = asInfo['as']					# AS123 
        asRegisteredCode = asInfo['registeredCode']		# Short-form e.g.ARCOR
        
        msg = ip + "," + `bootTimeEpochHours` + "," + ip + ":" + Username + "," + "os=" + os + ",hops=" + hops + ","\
        + asRegisteredCode + ",now=" + nowStr + "," + `now` + ",bootTime=" + bootTimeStr + "," + `bte` + ",fw=" + fw + ",nat=" + nat
        
        print "WriteSecViz3() = " + msg
        
        fpOut = open(r'/home/var/log/kojoney_tail_secviz3_uptime.csv','a')
        print >> fpOut,msg 
        fpOut.close()

    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeSecViz3() exception caught = " + `e` + " ip=" + ip)

# Candidate to replace secviz4 - uses source port from firewall and netflow logs to get accurate uptime
# Write Security Visualisation data to be processed by AfterGlow to .csv file
# This file is used for correlating haxx0r IP stack uptime with non-Kojoney events e.g. iptables and netflow events
# These events work because they have source port needed for accurate uptime calculation 
# Need to touch this file
# add hops ?
def writeSecViz4(ip,srcPort,dstIP,dstPort,event):

    #print "entered writeSecViz4()"
    now = time.time()
    
    try:    
        p0fInfo = p0fcmd.getP0fInfo(ip,srcPort,dstIP,dstPort);
        if p0fInfo['result'] == True :				# p0f data is available
            hops = p0fInfo['hops']
            os   = p0fInfo['genre']
            fw   = p0fInfo['firewall']
            nat  = p0fInfo['nat'] 
            if p0fInfo['uptime'] == "?":
                uptime = 0
            else :
                uptime = p0fInfo['uptime'] 
                
            #if p0fInfo['genre'] == "Linux" :
            #    uptime = p0fInfo['uptime'] 
            #    btes = now - int(uptime)
            #    hops = p0fInfo['hops']    
            #else:						# probably Windows
            #    uptimeHours = 0
            #    btes        = 0
            #    uptime      = 0
        else:							# p0f data not read OK
            hops   = 0        
            os     = "?"
            fw     = "?"
            nat    = "?"
            uptime = 0
                          
        # get current time
        timeTuple = time.localtime(now)
        nowStr    = time.asctime(timeTuple)			# current time
            
        # calc haxx0r bootTime based on seconds 	
        btes = now - int(uptime)
        timeTuple   = time.localtime(btes)
        bootTimeStr = time.asctime(timeTuple)
        bteh = int(btes/3600)
        #print "bootTimeEpochHours:" + `bteh`
        
        #asInfo = rch_asn_funcs.ip2asn(ip)
        asInfo = ipintellib.ip2asn(ip)
        asNum = asInfo['as']					# AS123 
        asRegisteredCode = asInfo['registeredCode']		# Short-form e.g. ARCOR
        
        # old code from secviz3
        #msg = ip + "," + `bootTimeEpochHours` + "," + ip + ":" + Username + "," + "os=" + os + ",hops=" + hops + ","\
        #+ asRegisteredCode + ",now=" + nowStr + "," + `now` + ",bootTime=" + bootTimeStr + "," + `bte` + ",fw=" + fw + ",nat=" + nat
        
        # Add nowStr so that can see if the bteh/btes stays constant for multiple visits...
        # Log boottime epoch as bteh and btes to see how accurate they are
        # todo : add flow details 
        msg = ip + "," + `bteh` + "," + event + "," + os + "," + asNum + "(" + asRegisteredCode + ")" + ",now=" + nowStr + ",bootTime=" + bootTimeStr + ",btes=" + `btes` + ",uptime=" + `uptime`
        
        print "WriteSecViz4(): " + msg
        
        # file needs to be touched
        fpOut = open(r'/home/var/log/kojoney_tail_secviz4_uptime.csv','a')
        print >> fpOut,msg 
        fpOut.close()

    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeSecViz4() exception caught = " + `e` + " ip=" + ip)


# Send a Tweet from  honeytweeter
# username is actually the global variable Username
def sendTweetCLI(sessionid,username,ip,cli):
        
    print "Entered sendTweetCLI()"
    
    now=time.time()
    
    try:
        # sessionid of -1 indicates that we have no AUTH_OK event and so no username - so don't tweet it
        if (int(sessionid) < 0):
            print "sessionId < 0 -> no previous AUTH_OK event to get username"
            return
        
        # This is flawed in that most p0f variables returned will be OK but uptime needs the source port specified   
        # Will this fail fo rhoneyd subsytemed Kojoney sessions ? 172.31.0.1 ?
        p0fInfo = p0fcmd.getP0fInfo(ip,"0","172.31.0.67","22");
        if p0fInfo['result'] == True :		# p0f data is available
            hops = p0fInfo['hops']
            os   = p0fInfo['genre']
            fw   = p0fInfo['firewall']
            nat  = p0fInfo['nat'] 
            if p0fInfo['genre'] == "Linux" :
                uptime = p0fInfo['uptime'] 
                bte = now - int(uptime)		# boot time (epoch secs)
                hops = p0fInfo['hops']    
            else:
                uptimeHours = 0
                bte = 0
        else:					# p0f data not read OK
            hops = 0        
            os   = "?"
            fw   = "?"
            nat  = "?"
            bte  = 0
                  
        # get current time
        timeTuple = time.localtime(now)
        nowStr    = time.asctime(timeTuple)
            
        # calc haxx0r bootTime 	
        #timeTuple   = time.localtime(bte)
        #bootTimeStr = time.asctime(timeTuple)
        bteh = int(bte/3600)	# bteh = boot time epoch (hours)
        
        # Get DNS info
        dnsInfo = ipintellib.ip2name(ip)
        dnsName = dnsInfo['name']
        
        # WHOIS information
        #asInfo = rch_asn_funcs.ip2asn(ip)
        asInfo = ipintellib.ip2asn(ip)
        asNum = asInfo['as']					# AS123 
        asRegisteredCode = asInfo['registeredCode']		# Short-form e.g.ARCOR
        
        # GeoIP information
        geoIP = ipintellib.geo_ip(ip)
        countryCode = geoIP['countryCode']
        city        = geoIP['city']
        longitude   = geoIP['longitude']			# Used to calc approx. localtime
        
        # Compact usual returns
        if asNum.find("AS-none")!= -1 :
            asNum="?"
        if asRegisteredCode.find("failed")!= -1 :
            asRegisteredCode="?"
        if countryCode.find("None") != -1 :
            countryCode="?"
        if city.find("None") != -1 :
            city="?"
            
        # Construct Tweet
        # todo - if os = windows, do not add bteh
        msg = "kojoney,mars,USER,ssh,sid=" + `sessionid` + ",IP=" + ip + "," + asNum + "(" + asRegisteredCode + ")" + ","\
        + countryCode + "," + city + "," + "%.2f" % longitude + "," + os + "," + hops\
        + ",fw=" + fw + ",nat=" + nat + ",bteh=" + `bteh`\
        + "," + username + "@hpot$ " + cli
    
        sendTweet(msg)       
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : sendTweetCLI() exception caught = " + `e` + " ip=" + ip)

# visualise the Tweets
# add timestamp as last (unusable) field
def writeSecViz5(tweet):

    #print "entered writeSecViz5()"
    now = time.time()
    
    try:    
        fields=tweet.split(",")
        #print "writeSecViz() : " + `fields`
        
        timeS       = fields[0]
        type        = fields[1]		# e.g. ids , flow , amun, aaa
        node        = fields[2]		# e.g. mars
        phase       = fields[3]		# 
                
        # Filter
        # Ignore Amun events - no IP address
        if type.find("amun") != -1 :		
            return
        
        # Ignore AAA events - no IP address
        #if type.find("aaa") != -1 :		
        #    return
        
        # Extract event dependent fields
        srcIP       = fields[8]
        dstIP       = fields[10]
        event       = fields[13]		# e.g. full Snort message i.e. "[1:2323232:4] sdklsdklsdklsdk"
        
        # Additional info not used by Afterglow
        countryCode = fields[4]
        ASname      = fields[5]
        dstPort     = fields[11]
        proto       = fields[9]
        
        # Strip () from destination port
        dstPort = dstPort.lstrip('(')
        dstPort = dstPort.rstrip(')')
        
        # Replace proto with single character if one of TCP,UDP,ICMP
        if proto == '[6]' :
            proto = 'T'
        if proto == '[1]' :    
            proto = 'I'
        if proto == '[17]' :
            proto = 'U'    
        if proto.find('[T]') != -1 :
            proto = 'T' 
        if proto.find('[U]') != -1 :
            proto = 'U'
        if proto.find('[I]') != -1 :
            proto = 'I' 
        
        # Compress Snort message down to purely the SID
        # How do I know the source of the SID i.e ET or standard Snort ?        
        if type == "ids":
            a = event.lstrip(" ")
            a = event.rstrip(" ")
            b = a.split(' ')[0]			# [1:232323:4]
            #print "b is " + `b`
            c = b.split(":")			# '[' , '232323' , '4' , ']'
            #print "c is " + `c`
            detail = c[1]			# 232323
            #print "detail is " + `detail`
            if event.find("ET ") != -1:		# Append "ET" if Emerging Threats signature
                detail = detail + "@ET"
        else:
            detail = event
            
        # Remove aaA redundant characters    
        detail=detail.replace(" cmd=","") 
        detail=detail.replace(" <cr>",":") 

        # Compress Phase
        if phase.find("FLOOD") != -1 :
            phase = "FLD" 
        if phase.find("RECON") != -1 :
            phase = "REC" 
        if phase.find("SUSPC") != -1 :
            phase = "SUS" 
        if phase.find("OTHER") != -1 :
            phase = "-" 
        if phase.find("REINF") != -1 :
            phase = "REI" 
        
        # Compress Type
        if type.find("ids") != -1 :
            type = "IDS"
        if type.find("ips") != -1 :
            type = "IPS" 
        if type.find("flow") != -1 :
            type = "FL" 
        if type.find("web") != -1 :
            type = "WW" 
        if type.find("fwall") != -1 :
            type = "FW" 
        if type.find("Aaa") != -1 :
            type = "AAU"
        if type.find("aaA") != -1 :
            type = "AAC" 
        if type.find("amun") != -1 :
            type = "AM" 
        if type.find("acl") != -1 :
            type = "ACL" 
                
        # For flow-derived events, construct the secviz file output fields[0-2] + additional info     
        msg = srcIP + "," + type + ":" + node + ":" + phase + ":" + detail + proto + dstPort + "," + dstIP + ",time=" + timeS + ",countryCode=" + countryCode + ",ASname=" + ASname + ",event=" + event
        
        # Do not visualise return flows - this needs to be done using proper correlation in next version
        # Needs more thought
        #if int(dstPort) < 1024 and srcIP == "HPOT" :
        #    syslog.syslog("writeSecviz5() discarded return flow : " + msg)  
        
        # Compress sources
        msg=msg.replace("bg_rtr","B")		# BG Router
        msg=msg.replace("node9","R")		# Honeypot Router
        msg=msg.replace("mars_fp","H")		# Honeypot
        msg=msg.replace("mars","H")		# Honeypot - fwsnort
        msg=msg.replace("adsl","A")		# WRT ADSL router
        
        # Misc compression
        msg=msg.replace("FEED:netflow","")
        msg=msg.replace("FEED:iptables","")
        msg=msg.replace("cli:router:","")
        msg=msg.replace('T22/23',"")
        msg=msg.replace("ACL:router:EVENT:","")
        
        msg=msg.replace("p0f:H:FEED:OS=","")
        msg=msg.replace("WW:H:FEED:File does not exist: ","")
          
        #print "WriteSecViz5(): " + msg
        
        # file needs to be touched
        fpOut = open(r'/home/var/log/kojoney_tail_secviz5_tweets.csv','a')
        print >> fpOut,msg 
        fpOut.close()

    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeSecViz5() exception caught = " + `e` + " tweet=" + tweet)

# create Sebek data to be processed by kojoney_viz
# add timestamp as last (unusable) field
# ip is the IP of the Sebek node and not the attacker 
def writeSecVizSebek(uid,pid,ip,countryCode,cmd,cmdStr):

    try:    
        #print "entered writeSecVizSebek()"
        now = time.time()
    
        # get current time
        timeTuple = time.localtime(now)
        nowStr    = time.asctime(timeTuple)
        
        #msg = "SEBEK" + "," + cmd + ":" + cmdStr + "," + "U=" + uid + ":" + "P=" + pid + "," + nowStr + " GMT" 
        msg = "SEBEK" + "," + "U=" + uid + ":P=" + pid + "," + cmd + ":" + cmdStr + "," + nowStr + " GMT" 
        #print msg
        
        if len(cmdStr) == 0 :			# No point in displaying nothing..
            return
        
        if cmdStr.find("libssh") != -1 :	# Get lots during brute-force attacks
            return
        
        if cmdStr.find("PuTTY") != -1 :		# User has attempted a login ?
            return
            
        # file needs to be touched    
        fpOut = open(r'/home/var/log/kojoney_sebek.csv','a')
        print >> fpOut,msg 
        fpOut.close()
        
        # Send an e-mail alert for events indicating that honeypot is being abused and you might want to lock it down 
        #if cmdStr.find("./") != -1 or cmdStr.find("wget ") != -1 or cmdStr.find("rm ") != -1 :      
        if cmdStr.find("./") != -1 :      
            email = "An unauthorised intruder is currently logged into the honeypot and executing code :-\n\n" + "uid=" + uid + "\n" + "pid=" + pid + "\n" + "process=" + cmd + "\n\n" + "cmd=" + cmdStr
            print email
            statusAlert("haxx0r online and executing code !",email)
            playAlert.playAlert(1)	# play Defcon 1 MP3 sound on botwall machine
                    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : writeSecVizSebek() exception caught = " + `e`)

# obsolete
# wrapper for sending Tweets
def sendTweet(tweet_raw):
    return;
    
    global TweetClient
    
    MAXTWEET_LEN=139			# max chars to send
    
    now = time.time()
    
    #print "sendTweet(): raw = " + tweet_raw
    
    try:
        # Anonymise and shorten actual honeypot IP address to HPOT
        tweet = tweet_raw.replace("172.31.0.67","HPOT")		# e.g. not managed via Honeyd        
        tweet = tweet_raw.replace("172.31.0.1" ,"HPOT")		# e.g. managed via Honeyd
        tweet = tweet_raw.replace("192.168.1.9","ROUTER")        
                
        # Try to shorten longer words in Snort messages
        tweet = tweet.replace("Classification: ","C:") 
        tweet = tweet.replace("Priority: ","P:") 
        tweet = tweet.replace("Administrator","Admin") 
        tweet = tweet.replace("Shellcode","SC") 
        tweet = tweet.replace("Windows Source","Win")
        tweet = tweet.replace("Information","Info")
        tweet = tweet.replace("{TCP}","{T}")
        tweet = tweet.replace("{ICMP}","{I}")
        tweet = tweet.replace("{UDP}","{U}")
        tweet = tweet.replace("(portscan) ","")
        tweet = tweet.replace("Executable ","Exe ")
        tweet = tweet.replace("Privilege ","Priv ")
        tweet = tweet.replace("ATTACK_RESPONSE","ATT_RESP")
        tweet = tweet.replace("ATTACK-RESPONSES","ATT_RESP")
        tweet = tweet.replace("Microsoft","M$oft")		# personal spite
        tweet = tweet.replace("MS ","M$oft ")			# personal spite
        tweet = tweet.replace("symantec","Symantec")		# grammar
        tweet = tweet.replace("Unauthenticated","Unauth")
        tweet = tweet.replace("antivirus","AV")
        tweet = tweet.replace("download","dload")
        tweet = tweet.replace("CMD Shell","cmd.exe")		# consistency
        tweet = tweet.replace("Attempted","Attempt")
        tweet = tweet.replace("NETBIOS","NBIOS")
        tweet = tweet.replace("version","ver")
        tweet = tweet.replace("Request","req")
        tweet = tweet.replace("overflow","oflow")
        tweet = tweet.replace("xor","XOR")
        tweet = tweet.replace("was detected","detected")
        
        tweet = tweet.replace("Linux","LNX")
        tweet = tweet.replace("Windows","WIN")
        tweet = tweet.replace("FreeBSD","FBSD")
        tweet = tweet.replace("OpenBSD","OBSD")
        tweet = tweet.replace("NetBSD","NBSD")
        
        tweet = tweet.replace("signature match","")		# PSAD
        tweet = tweet.replace("crouchr","****")			# AAA logs for router login
            
        # construct and prepend a minimal localtime timestamp : HHMM   
        tuple=time.localtime(now)
        timestamp = "%02d" % tuple.tm_hour + "%02d" % tuple.tm_min    
        tweet = timestamp + "," + tweet
    
        # truncate (concatenate in future ?) long tweets 
        if len(tweet) >= MAXTWEET_LEN:
            tweet=tweet[0:MAXTWEET_LEN]
            tweet=tweet + "+"				# + indicates tweet was truncated
            #syslog.syslog("kojoney_tail.py : sendTweet() msg built [truncated to " + `len(tweet)` + " chars] : tweet=" + tweet)
        else:     
            pass
            #syslog.syslog("kojoney_tail.py : sendTweet() msg built : " + tweet)
            
        # basic visualisation of the Tweets
        #writeSecViz5(tweet)
        
        # Filtering
        # ---------
        #print "Before filtering , tweet = " + tweet
        
        # hack - do not Tweet firewall feeds
        #if tweet_raw.find("FEED") != -1 :
        #    return
        
        # hack - do not Tweet netflow feeds    
        #if tweet_raw.find("flow") != -1 :
        #    return

        # hack - do not Tweet firewall events feeds    
        #if tweet_raw.find("adsl") != -1 :
        #    return
    
        # hack - do not Tweet Voip adapter honeyd     
        if tweet_raw.find("172.31.0.71") != -1 :
            return
    
        # actually send the tweet
        status = TweetClient.PostUpdate(tweet)    
        print "notify     : " + tweet
        syslog.syslog("kojoney_tail.py : sendTweet() Tweet sent : " + tweet)
            
        # log the sent Tweets - have a .txt extension so Windoze can open it up
        fpOut = open(r'/home/var/log/tweets.log.txt','a')
        print >> fpOut,"TWEET=" + tweet 
        fpOut.close()

        # This is too crude - it is triggering on Cisco p0f
        # send an e-mail if the exploit contains particularly interesting keywords
        #if tweet.find("Cisco") != -1 or tweet.find("Conficker") != -1 or tweet.find("Downadup") != -1 :
        #    statusAlert("Exploit du jour detected",tweet)
        
        # send an e-mail if router command-line is being entered
        if tweet.find("@RTR") != -1 :
            statusAlert("Router honeypot being accessed",tweet)
        
        time.sleep(1)					# crude rate limit 
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : sendTweet() exception caught = " + `e` + " tweet=" + tweet)

# main routine for writing to kojoney Channel        
def makeMsg(cliNum,ip,msg):
    now =time.time()
    timeTuple= time.localtime(now)
    
    # create the complete log entry text
    a = time.asctime(timeTuple) + "," + Version + "," + ip + "," + "%06d" % SessionId + "," + msg
    
    #print a 
    fpOut = open(r'/home/var/log/kojoney_tail.log','a')
    #syslog.syslog(a)
    print >> fpOut,a
    fpOut.close()

# 15 degrees = 1 hour - rounded down
# this needs unit testing
def calcLocalTime(longitude):
    if int(longitude) > 360 :	# GeoIP returns 999.0 if failed
        offsetSecs = 0;
    else:    
        offsetSecs = 3600 * int(longitude / 15)
    
    now = time.time()
    localTime = now + int(offsetSecs)
    
    #print "offsetSecs        : " + `offsetSecs`
    #print "localTime (epoch) : " + `localTime`
    timeTuple = time.localtime(localTime)
    #print "localTime         : " + time.asctime(timeTuple)
    
    return time.asctime(timeTuple)

# calculate haxx0r PC boot time in "My Time"      
# uptime is string - uptime in seconds - assumes p0f v3.0.0 is running
# uptime could be '?' e.g. if from a Windows box
# setting boottime to 0 indicates bootime is not valid

def calcBootTime(uptime):
    bootTime = {}
        
    now = time.time()			# epoch seconds
    if uptime == '?':			# probably Windows box    
        bte = 0
    else:  
        bte = now - int(uptime)
         	
    bootTime['epoch'] = `bte`
    #print "bootTime['epoch'] = " + `bootTime['epoch']`
    
    timeTuple = time.localtime(bte)
    bootTime['timeStr'] = time.asctime(timeTuple)
    #print "bootTime['timeStr'] = " + time.asctime(timeTuple)
    
    # record time of last visit by this IP
    bootTime['lastVisit'] = `now`
    timeTuple = time.localtime(now)
    bootTime['lastVisitStr'] = time.asctime(timeTuple) 
    
    return bootTime 
                           
# return True is backspace or Up arrow etc. are pressed indicated a human
# TODO : send an email 
def isHuman(cliList):
    for x in cliList:
        if (x.find('\x7f') != -1) or (x.find('\x1b') != -1):
            return True
    return False    
    
    
# extract source IP from Snort log
# source IP can be either 1.2.3.4:80 or 1.2.3.4 (i.e. include a port number)
# make this a function and extend to extract srcip,srcport,dstIP,dstPort and return a dictionary

def getSrcIPSnort(line):
    sock={}
    try:
        line=line.strip("\n")
        #print "getSrcIPSnort() : line is " + line.strip("\n")
        a=line.find("}")
    
        if a == -1:	# Failed to find '}'
            print "Failed to find } anchor"
            syslog.syslog("kojoney_tail.py : getSrcIPSnort() failed to find } anchor in " + line)
            sock['ip']   = "0.0.0.0"
            sock['port'] = "-1"
            return sock
        
        b = line[a:].strip("\n")
    
        #print "b=" + b
        c=b[2:]			# skip "{ "
        #print "c=[" + c +"]"
    
        d = c.split(" ")		# d = 1.2.3.4 or 1.2.3.4:345
        #print "d is " + `d`
    
        if d[0].find(":") != -1 :	# d = 1.2.3.4:80
            sock['ip']  = d[0].split(":")[0]
            sock['port'] = d[0].split(":")[1]
        else:				# TCP portscan is this type
            #print "getSrcIPSnort() IP without port number found d=" + d
            sock['ip']   = d[0]
            sock['port'] = "-1"
            
        #print "getSrcIPSnort() : ip is [" + sock['ip'] + "] and port is [" + sock['port'] + "]"
    
        return sock
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : getSrcIPSnort() exception caught = " + `e` + " line=" + line.strip("\n"))
        return None

# extract destination IP from Snort log
# IP can be either 1.2.3.4:80 or 1.2.3.4
# make this a function and extend to extract srcip,srcport,dstIP,dstPort and return a dictionary
def getDstIPSnort(line):
    sock={}
    
    try:
        line=line.strip("\n")
        #print "getDstIPSnort() : line is " + line
        a=line.find("}")
    
        if a == -1:	# Failed to find '}'
            syslog.syslog("kojoney_tail.py : getDstIPSnort() failed to find } anchor in " + line)
            sock['ip']   = "0.0.0.0"
            sock['port'] = "-1"
            return sock
        
        b = line[a:].strip("\n")
    
        #print "b=" + b
        c=b[2:]				# skip "{ "
        #print "c=[" + c +"]"		# c = 1.2.3.4:80 -> 3.4.5.6:80
    
        d = c.split(" ")		# d = {'1.2.3.4', '->', '3.4.5.8'}
        #print "d is " + `d`
    
        if d[2].find(":") != -1 :	# d = 1.2.3.4:80
            sock['ip']   = d[2].split(":")[0]
            sock['port'] = d[2].split(":")[1]
        else:
            sock['ip']   = d[2]
            sock['port'] = "-1"
            
        #print "getDstIPSnort() : ip is [" + sock['ip'] + "] and port is [" + sock['port'] + "]"
    
        return sock
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : getDstIPSnort() exception caught = " + `e` + " line=" + line.strip("\n"))
        return None

def processNepenthes(line):
    try:
        line=line.strip("\n")
        print "kojoney_tail.py: processNepenthes() : line is " + line
        syslog.syslog("nepenthes=" + line)
        
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processNepenthes() exception caught = " + `e` + " line=" + line.strip("\n"))
        return None

# Process Snort log entries
# Look for initial reconnaisance
#vi.e. NMAP pings etc
# TODO : add Nmap scan but only if dest is 172.31.0.67:22
# TODO : dump never seen before messages to a text file
# todo : add writeSecViz4 for TCP-related events (i.e. can get an accurate uptime)
# create the phase from the snort message i.e look for EXPLOIT
# todo - reinstate the [x:SIG:Rev] for visualisation
def processSnort(line):
    try:        
        print "snort IDS  : " + line.strip('\n')
        
        # Filter out non-Snort messages
        if line.find("last message repeated") != -1:
            return

        # Extract the Snort event message
        fields=line.split(' ')
        #print fields
        #snortMsg = " ".join(fields[5:])		# skip Snort timestamp
        #snortMsg = snortMsg.strip('\n');
                     
        # Extract flow information from Snort message             
        srcSock = getSrcIPSnort(line)
        dstSock = getDstIPSnort(line)             
        srcIP   = srcSock['ip']
        dstIP   = dstSock['ip']
        srcPort = srcSock['port']
        dstPort = dstSock['port']
        
        # Extract proto from Snort
        if line.find("{ICMP}")  != -1 :
            proto = "1"
        elif line.find("{TCP}") != -1 :
            proto = "6"
        elif line.find("{UDP}") != -1 :
            proto = "17"
        else :
            proto = "?"            
        
        # Extract the SID
        pat = "\[[0-9]:([0-9]*):[0-9]*"
        sid = re.findall(pat,line)[0]
        
        snortMsg = "sid=" + sid + ",ev=" + getSnortInfo.getSnortMsg(sid) + ",ct=" + getSnortInfo.getSnortAtom(sid,"classtype") + ",ref=" + getSnortInfo.getSnortAtom(sid,"reference") 
        #print snortInfo
        
        # Do not report "attacks" against Twitter, e.g. use of unencrypted password SID
        if dstIP.find("168.143.161.") != -1:
            return
        if dstIP.find("168.143.171.") != -1:
            return
        if dstIP.find("168.143.162.") != -1:
            return
        if dstIP.find("128.121.146.") != -1:
            return

        # Do not report "attacks" from local LAN 
        # Disable this during debugging
        #if srcIP.find("192.168.1.") != -1 or dstIP.find("192.168.1.") != -1 :
        #    return
        
        # Get OS type    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);	# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :				# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat']
        else:
            os  = "?"
            nat = "?"
        
        # Anonymise/compress honeypot IP address
        if srcIP == HPOT:
            srcIP   = "HPOT"
      
        if dstIP == HPOT:
            dstIP = "HPOT"
        
        # Anonymise/compress honeyd IP address
        if srcIP == HONEYD:
            srcIP   = "HPOT"
      
        if dstIP == HONEYD:
            dstIP = "HPOT"
        
        # Anonymise/compress router IP address
        if srcIP == ROUTER:
            srcIP   = "ROUTER"
      
        if dstIP == ROUTER:
            dstIP = "ROUTER"

        #print "got to here"            
        # Does wrapping the number in () make it print as a negative in Excel ?
        flow = srcIP + "," + os + "{" + nat + "}" + "," + srcPort + ",[" + proto + "]," + dstIP + "," + dstPort + ",*"                
        #flow = srcSock['ip'] + ",(" + srcSock['port'] + "),[" + proto + "]," + dstSock['ip'] + ",(" + dstSock['port'] + ")"               
        #print "processSnort() : line  is " + line.strip("\n")
        #print "processSnort() : flow  is " + flow

        # Filter out unwanted snort alerts
        if line.find("ET POLICY Outbound TFTP ACK") != -1 :	# Malware downloads trigger many of these   
            return  
           
        # Tweet interesting IDS alerts 
        if line.find("ICMP PING ") != -1 or line.find("ICMP superscan ") != -1 or line.find("(portscan) ") != -1 :   
            msg = "ids,mars,RECON," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg  
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif line.find("TFTP Get ") != -1 :
            msg = "ids,mars,REINF," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg  
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif line.find("pcap") != -1 :		# RCH-defined pcap capture Snort rules defined in local.rules
            msg = "ids,mars,PCAP," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg  
            makeMsg(0,"0",msg)
        elif line.find("Potential SSH Scan ") != -1 :
            msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif line.find("LibSSH Based ") != -1 :
            msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            makeMsg(0,"0",msg)
            # sendTweet(msg) - too many to Tweet
        elif line.find("DNS SPOOF ") != -1 :
            msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg  
            makeMsg(0,"0",msg)
            # sendTweet(msg) - false positive - do not Tweet
        elif line.find("SQL Worm ") != -1 :
            msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            makeMsg(0,"0",msg)
            sendTweet(msg) 
        else :
            if line.find("Executable code") != -1  :				# attempt made to exploit a vulnerability
                msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg
            elif line.find("Successful Administrator Privilege") != -1 :	# host has been compromised 
                msg = "ids,mars,USER_#," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("ET SCAN") != -1 :	# host has been compromised 
                msg = "ids,mars,RECON," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("Attempted Administrator Privilege") != -1 :		# host has been compromised 
                msg = "ids,mars,EXP_A?," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("Information Leak") != -1 :					# scan/recon 
                msg = "ids,mars,RECON," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("Generic Protocol") != -1 :	 
                msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg
            elif line.find("Trojan") != -1 :	
                msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("vulnerable web") != -1 :	
                msg = "ids,mars,EXPLT_W," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("Misc Attack") != -1 :	
                msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            elif line.find("Misc activity") != -1 :	
                msg = "ids,mars,EXPLT," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg 
            else:
                msg = "ids,mars,OTHER," + getIntelStr(srcSock['ip'],dstSock['ip']) + "," + flow + "," + snortMsg
            makeMsg(0,"0",msg)
            sendTweet(msg)
            
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processSnort() exception caught = " + `e` + "line=" + line)

# Add Snort alerts to a file to see if the (later) Netflow can be found for correlation
#def add2FlowWatchList(flow,event):
#    fpOut = open(r'/home/var/log/ids_flows.log','a')
#    print >> fpOut,flow + "," + event
#    fpOut.close()

# This is just alpha at the moment to check the file rollover logic
# todo : extract the destination IP and perform ipintel functions on it
def processAmunDownload(line):
    
    pat = r'\d+\.\d+\.\d+\.\d+'		# locate a number of IP addresses
    
    try:        
        print "amun_dload : " + line.strip('\n')
  
        if line.find("ftp connect to") != -1:
            ips = re.findall(pat,line)
            dstIP = ips[0]
            flow = "HPOT,(-1),[TCP]," + dstIP + ",(21)"               
            event = getIntelStr("-1",dstIP) + "," + line.strip('\n')		
            msg = "amun,mars,REINF," + flow + "," + event    
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif line.find("TFTP Request") != -1:		# log only contains src ip=172.31.0.67            
            event = "*,*,*,*," + line.strip('\n')
            msg = "amun,mars,REINF," + event    
            makeMsg(0,"0",msg)
            sendTweet(msg) 
        elif line.find("[ftp_download]") != -1:		# log all the FTP session, but no Tweet : why no tweet ?
            event = "*,*,*,*," + line.strip('\n')
            msg = "amun,mars,REINF," + event    
            makeMsg(0,"0",msg)        
        #else :
        #    syslog.syslog("processAmunDownload(): " + line)	# log the entry    
            
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processAmunDownload() exception caught = " + `e` + "line=" + line)


# Process FW snort entries
# All flows are inbound
# Inline blocking by iptables i.e. IPS
def processFWsnort(line):
    
    try:        
        line = line.strip('\n')
        print "processFWsnort() : IPS : line read from iptables file : " + line
             
        a = line.find("SRC=")		# source IP
        b = line.find("SPT=")		# source port
        c = line.find("DST=")		# destination IP
        d = line.find("DPT=")		# dest port
        e = line.find("PROTO=")		# TCP UDP
        f = line.find("TTL=")		# TTL for OS fingerprinting compared to p0f
        g = line.find("ID=")		# IP ID
        h = line.find("SID")            # FWSnort signature
        i = line.find("DRP")		# Traffic was dropped
        
        # flow1 - mandatory flow info
        srcIP   = line[a:].split(" ")[0].split("=")[1]
        srcPort = line[b:].split(" ")[0].split("=")[1]
        dstIP   = line[c:].split(" ")[0].split("=")[1]    
        dstPort = line[d:].split(" ")[0].split("=")[1]    
        proto   = line[e:].split(" ")[0].split("=")[1]
        
        # flow2 - additional flow info 
        ttl     = line[f:].split(" ")[0].split("=")[1]
        ipid    = line[g:].split(" ")[0].split("=")[1]    
        sid     = line[h:].split(" ")[0] 
        sid     = sid[3:]		# ignore the "SID" on the front
            
        sensorName = "mars"		# hostname of sensor 

        # Do not report "attacks" against Twitter, e.g. use of unencrypted password SID
        if dstIP.find("168.143.161.") != -1:
            return
        if dstIP.find("168.143.171.") != -1:
            return
        if dstIP.find("168.143.162.") != -1:
            return
        if dstIP.find("128.121.146.") != -1:
            return

        # Do not report certain IDS events
        if sid == "2008118" :	# TFTP transfer - get one per ACK
            return

        # Do not report "attacks" from local LAN
        # Disable this during debugging
        #if srcIP.find("192.168.1.") != -1 or dstIP.find("192.168.1.") != -1 :
        #    return
        
        # exactly the same format as Snort
        snortMsg = "sid=" + sid + ",ev=" + getSnortInfo.getFwsnortMsg(sid) + ",ct=" + getSnortInfo.getFwsnortAtom(sid,"classtype") + ",ref=" + getSnortInfo.getFwsnortAtom(sid,"reference") 
        #print snortInfo
        
        # Get OS type    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);	# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :				# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat'][0]
        else:
            os  = "?"
            nat = "?"
        
        # Anonymise/compress mars honeypot IP address 
        if srcIP == HPOT :
            srcIP = "HPOT"
        if dstIP == HPOT :
            dstIP = "HPOT"
                
        # Anonymise/compress honeyd IP address
        if srcIP == HONEYD:
            srcIP   = "HPOT"
      
        if dstIP == HONEYD:
            dstIP = "HPOT"
        
      # Anonymise/compress router (node9) honeypot IP address
        if srcIP == ROUTER:
            srcIP   = "ROUTER"
      
        if dstIP == ROUTER:
            dstIP = "ROUTER"
        
        # This is the ideal where there is the proto number ?
        if line.find("ICMP")  != -1 :
            proto = "1"
        elif line.find("TCP") != -1 :
            proto = "6"
        elif line.find("UDP") != -1 :
            proto = "17"
                      
        flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + ",IN"		# hard-code the direction
        flow2 = "ttl=" + ttl + ",ipid=" + ipid 
        
        # Set the attack phase based on the SID
        # for now, just set all of them to Exploit phase
        phase = "EXPLT"
        
        if i != -1:	# traffic was dropped
            event = "DROP:" + snortMsg
        else:		# traffic was passed
            event = snortMsg    
        
        # Construct the message       
        msg = "ips" + "," + sensorName + "," + phase + "," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + event + "," + flow2
        print "fwsnort    : " + msg
        
        # Log to kojoney_tail.log    
        # remove false postivies from the actual snort rules
        #if sid == "254":	# false positive DNS TTL=1
        #    return
            
        makeMsg(0,"0",msg)
        sendTweet(msg)	# hack to get secviz5() called
        
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processFWsnort() exception caught = " + `e` + "line=" + line)


# 
def processPSAD(line):
    
    # default is recon - override based on the SID
    phase = "RECON"
    srcIP   = "-1"
    dstIP   = "-1"
    proto   = "IP"
    srcPort = "-1"
    dstPort = "-1"

    pat = r'\d+\.\d+\.\d+\.\d+'		# locate a number of IP addresses
        
    try:        
        line = line.strip('\n')
                
        # ignore if this is not a psad-originated syslog entry
        if line.find("psad") == -1:
            return
          
        print "processPSAD() : line read from log file : " + line
    
        # locate IP addresses in the event
        ips = re.findall(pat,line)        
        #print ips
        
        # todo - parse relevent additional info e.g. source IP,etc to construct a flow     
        # some information is lost from the original message - fix this in later version
        if line.find("scan detected") != -1:
            srcIP = ips[0]
            dstIP = ips[1]
            event = line[27:]			# skip pre-amble : full message
            event = "scan detected"
            phase = "RECON"
            #pat = "tcp: \[([0-9]*)\]"
            #pat = "udp: \[([0-9]*)\]"                  
            
        elif line.find("signature match:") != -1:
            print "processPSAD() : signature match"
            
            srcIP = ips[0]
            
            # old method for extracting message
            #event = line[27:]			# skip pre-amble
            #msg  = line[27:].split(":")	# skip pre-amble
            #msg  = msg[2].strip(" ")		# skip src IP and other fields
            phase = "EXPLT"
            
            # extract the SID
            pat = "sid: (\d+)"
            a = re.findall(pat,line)
            sid = a[0]
            
            # determine if is this rule from a PSAD signature or from a FWSNORT signature
            if line.find("fwsnort chain:" ) != -1 :	# FWSNORT
                msg       = getSnortInfo.getFwsnortMsg(sid)
                classtype = getSnortInfo.getFwsnortAtom(sid,"classtype")
                reference = getSnortInfo.getFwsnortAtom(sid,"reference")
            else:					# PSAD	
            	msg       = getSnortInfo.getPsadMsg(sid)
                classtype = getSnortInfo.getPsadAtom(sid,"classtype")
                reference = getSnortInfo.getPsadAtom(sid,"reference")
                        
            # presume not available for ICMP mesages
            #pat = "port: (\d+)"
            #a = re.findall(pat,line)
            #dstPort = a[0]
            # Snort, Fwsnort and PSAD all confirm to a common output format
            event = "sid=" + sid + ",ev=" + msg + ",ct=" + classtype + ",ref=" + reference 
            #print event
         
        elif line.find("added iptables auto-block") != -1:
            srcIP = ips[0]
            event = line[27:]			# skip pre-amble : full message
            event = "add-block:" + srcIP	# replace with a short version to make Tweet replaces easier : hack
            phase = "AR_ADD"			# Active Response : Added
        elif line.find("removed iptables auto-block") != -1:
            srcIP = ips[0]
            event = line[27:]			# skip pre-amble
            event = "del-block:" + srcIP
            phase = "AR_DEL"			# Active Response : Removed
        else:					
            return
                                 
        sensorName = "mars"			# hostname of sensor 
        
        # Anonymise/compress mars honeypot IP address 
        #if srcIP == HPOT :
        #    srcIP = "HPOT"
        #if dstIP == HPOT :
        #    dstIP = "HPOT"
      
        # Anonymise/compress router (node9) honeypot IP address
        #if srcIP == ROUTER:
        #    srcIP   = "ROUTER"
      
        #if dstIP == ROUTER:
        #    dstIP = "ROUTER"
        
        # This is the ideal where there is the proto number ?
        #if line.find("ICMP")  != -1 :
        #    proto = "1"
        #elif line.find("TCP") != -1 :
        #    proto = "6"
        #elif line.find("UDP") != -1 :
        #    proto = "17"
  
        # Do not report "attacks" against Twitter, e.g. use of unencrypted password SID
        if dstIP.find("168.143.161.") != -1:
            return
        if dstIP.find("168.143.171.") != -1:
            return
        if dstIP.find("168.143.162.") != -1:
            return
        if dstIP.find("128.121.146.") != -1:
            return

        # Ignore real destination IP to make the AfterGlow layout cluster PSAD events away from HPOT
        dstIP = "PSAD"
        direction = "*"              
        os = "*"
        flow1 = srcIP + "," + os + "," + "(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + "," + direction
        #flow2 = "ttl=" + ttl + ",ipid=" + ipid 
        
            
        # Construct the event message       
        msg = "psad" + "," + sensorName + "," + phase + "," + getIntelStr(srcIP,"-1") + "," + flow1 + "," + event 
        print "psad       : " + msg
        
        # Do not tweet scans etc.    
        if phase == "RECON" :
            return
            
        makeMsg(0,"0",msg)
        sendTweet(msg)		# hack to get secviz5() called
        
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processPSAD() exception caught = " + `e` + "line=" + line)


# Look for src port for data to Kojoney so that p0f can be accurate
# this is restricted to SSH at the moment - should it be extended in order to get more uptimes ?
# todo : Make this a stand-alone funtion for parsing iptables 
# add funny flags checking
def processFW(line):
    
    try:        
        # temporarily do nothing whilts the pinging from CPN IP SLA probe is ongoing
        return
        
        print "processFW() : line read from iptables file : " + line.strip('\n')
        
        # filter out irrelevent syslog messages
        if line.find("openvpn") != -1: 
            return
        if line.find("pppd") != -1: 
            return
        if line.find("last message repeated") != -1: 
            return
        if line.find("-- MARK --") != -1: 
            return
            
        # some sort of error parsing ICMP essages is filling up /var/log/messages so teporarily disabled    
        return

        a = line.find("SRC=")		# source IP
        b = line.find("SPT=")		# source port
        c = line.find("DST=")		# destination IP
        d = line.find("DPT=")		# dest port
        e = line.find("PROTO=")		# TCP UDP
        f = line.find("TTL=")		# TTL for OS fingerprinting compared to p0f
        g = line.find("ID=")		# IP ID
        h = line.find("WINDOW")		# TCP window
        i = line.find("SEQ")		# TCP sequence number
        j = line.find("IN")		# IN interface
        k = line.find("OUT")		# OUT interface
        l = line.find("LEN")		# IPv4 packet len
        
        # flow1 - mandatory flow info
        srcIP   = line[a:].split(" ")[0].split("=")[1]
        srcPort = line[b:].split(" ")[0].split("=")[1]
        dstIP   = line[c:].split(" ")[0].split("=")[1]    
        dstPort = line[d:].split(" ")[0].split("=")[1]    
        proto   = line[e:].split(" ")[0].split("=")[1]
        inIf    = line[j:].split(" ")[0].split("=")[1]
        outIf   = line[k:].split(" ")[0].split("=")[1]
                
        # flow2 - additional flow info - iptables mandatory fields 
        ttl     = line[f:].split(" ")[0].split("=")[1]
        ipid    = line[g:].split(" ")[0].split("=")[1]
        plen    = line[l:].split(" ")[0].split("=")[1]
        
        # flow2 - optional fields        
        if h != -1:
            window = line[h:].split(" ")[0].split("=")[1]
        else:
            window = "-1"
        
        if i != -1:
            seq = line[i:].split(" ")[0].split("=")[1]
        else:
            seq = "-1"
        
        fwname = "adsl"

        # Get OS type    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);	# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :				# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat'][0]				# 'y' not 'yes'
        else:
            os  = "?"
            nat = "?"
               
        # Anonymise/compress mars honeypot IP address 
        if srcIP == HPOT :
            srcIP = "HPOT"
        if dstIP == HPOT :
            dstIP = "HPOT"
      
        # Anonymise/compress honeyd IP address
        if srcIP == HONEYD:
            srcIP   = "HPOT"
      
        if dstIP == HONEYD:
            dstIP = "HPOT"
              
        # Anonymise/compress router (node9) honeypot IP address
        if srcIP == ROUTER:
            srcIP   = "ROUTER" 
        if dstIP == ROUTER:
            dstIP = "ROUTER"
        
        if inIf == "ppp0" :
            direction = "IN"
        else :
            direction = "OUT"    
        
        # This is the ideal where there is the proto number ?
        if line.find("ICMP")  != -1 :
            proto = "1"
        elif line.find("TCP") != -1 :
            proto = "6"
        elif line.find("UDP") != -1 :
            proto = "17"
                      
        flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + "," + direction
        flow2 = "len=" + plen + ",ttl=" + ttl + ",ipid=" + ipid + ",window=" + window + ",seq=" + seq  
        
        # do not print WHOIS lookups        
        if (dstPort == "43" or srcPort == "43" or srcPort == "4321" or dstPort == "4321") :	# ignore WHOIS
            return
        
        # Ignore BT DNS requests    
        if srcIP.find("194.72.6.57") != -1 or dstIP.find("194.72.6.57") != -1 :
            #print "fwall  : IGNORE : " + flow
            return
        
        # Ignore Google DNS requests    
        if srcIP.find("8.8.8.8") != -1 or dstIP.find("8.8.8.8") != -1 :
            #print "fwall  : IGNORE : " + flow
            return
        
        # Ignore NTP
        if (srcPort == "123" and dstPort == "123" and proto == "17") :	
            return
            
        # Ignore Twitter etc requests
        # need to filter source and destination IPs - i.e. for the return traffic    
        if ((dstIP.find("168.143.161.") != -1 or dstIP.find("168.143.162.") != -1 or dstIP.find("168.143.171.") != -1 or dstIP.find("128.121.") != -1 or dstIP.find("128.130.") != -1 or dstIP.find("128.242.") != -1) ) :
            return
        # need to filter source and destination IPs - i.e. for the return traffic    
        if ((srcIP.find("168.143.161.") != -1 or srcIP.find("168.143.162.") != -1 or srcIP.find("168.143.171.") != -1 or srcIP.find("128.121.") != -1 or srcIP.find("128.130.") != -1 or srcIP.find("128.242.") != -1)) :
            return

        event = "fwall" + "," + fwname + "," + "FEED," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "iptables" + "," + flow2
        print "iptables   : " + event
        
        # Log to kojoney_tail.log if this is an outgoing flow    
        if direction == "OUT" :
            makeMsg(0,"0",event)
            sendTweet(event)	# hack to get secviz5() called
          
        # Event detection
        # Interesting outbound events: FTP - test with slackpkg update from mars
        if srcIP == "HPOT" and dstPort == "21" and proto == "6":
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "FTP_XFER" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event)        
        
        if srcIP == "HPOT" and dstPort == "80" and proto == "6" :
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "HTTP_XFER" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event) 
        
        if srcIP == "HPOT" and dstPort == "443" and proto == "6" :
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "HTTPS_XFER" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event) 
        
        if srcIP == "HPOT" and dstPort == "6667" and proto == "6" :
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_XFER" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event) 
        
        if srcIP == "HPOT" and dstPort == "69" and proto == "17" :
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TFTP_XFER" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event)
        
        # Telnet access to router honeypot
        if dstIP == ROUTER and dstPort == "23" and proto == "6" :
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TELNET" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event)
        
        # SSH access to router honeypot
        if dstIP == ROUTER and dstPort == "22" and proto == "6" :
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event)
        
        # Use of Linux/*BSD tool by Script kiddy to probe common Windows ports - this does not seem to fire much
        # XTOOL = Cross-OS 
        if dstIP == "HPOT" and (os == "Linux" or os == "FreeBSD" or os == "OpenBSD") and (dstPort == "138" or dstPort == "139" or  dstPort == "445"):
            event = "fwall" + "," + fwname + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "XTOOL" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
            sendTweet(event)
        
        # Anomaly : Low TTL
        # if UDP and port approx 33437? [what is the range ?] - then this could be UNIX traceroute
        if int(ttl) < 10:
            event = "fwall" + "," + fwname + "," + "ANOMALY," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TTL<10" + "," + flow2
            print "iptables   : " + event
            makeMsg(0,"0",event)
        
        # TACACS messages from router (node7) to AAA on mars do not pass through ADSL so will not fire
        #if dstIP == "HPOT" and dstPort == "49" and proto == "6" :
        #    event = "fwall" + "," + fwname + "," + "FIREWALL," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TACACs+" + "," + flow2
        #    print "iptables   : " + event
        #    makeMsg(0,"0",event)
          
        # todo : crude OS fingerprinting ?
    
        # secViz : Log uptime if this is a TCP session towards the honeypot
        if proto == 'TCP' and dstIP == "172.31.0.67" :
            writeSecViz4(srcIP,srcPort,dstIP,dstPort,event)
        
        # too large and too frequent a message to Tweet without truncation / filtering
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processFW() exception caught = " + `e` + "line=" + line)

# todo : decode the port numbers from this
def processrtr(line):
    
    try:        
        line=line.strip("\n")
        print "processrtr() : line read from router syslog file : " + line
        
        fields = line.split(" ")
        #print fields    
        
        # SSH related events
        if line.find("%SSH-5") != -1 :
            msg = " ".join(fields[9:])
            event = "cli" + "," + "router" + "," + "EXPLT," + msg
        #    print "router   : " + event
            makeMsg(0,"0",event) 
            # breaks sendTweet -> sendTweet(event)
            return 
        
        # End if event is not ACL processing 
        if line.find("%SEC-6-IP") == -1:
            return
            
        number   = fields[11]
        action   = fields[12]
        proto    = fields[13]
        srcSock  = fields[14]
        dstSock  = fields[16]
        pkts     = fields[17]
        
        srcIP = srcSock.split('(')[0]
        dstIP = dstSock.split('(')[0]
        
        # extract source and destination port
        
        # Ignore LAN packets
        if srcIP == "192.168.1.70" or srcIP == "192.168.1.131" :
             return
        
        srcPort = "-1"
        dstPort = "22/23"	# decode actual port - bug
        
        if proto == 'tcp':
            proto = "6"
        if proto == 'udp':
            proto = "17"
        if proto == 'icmp':
            proto = "1"
          
        flow = srcIP + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")"
        #print "flow is  :" + flow
            
        # Interesting events
        if dstIP == ROUTER and dstPort == "22/23" and proto == "6":
             event = "acl" + "," + "router" + "," + "EVENT," + getIntelStr(srcIP,dstIP) + "," + flow + "," + "ACL_" + number + "," + pkts
        #    print "router   : " + event
             makeMsg(0,"0",event) 
             sendTweet(event)     
        # Anomaly
        # none so far
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processrtr() exception caught = " + `e` + "line=" + line)

# Process p0f log
# todo : extract src IP and preform getInteStr() on it
def processp0f(line):
    
    #pass
    #return
    
    try:        
        line = line.strip('\n')
        #print "p0f        : " + line[27:]	# skip the date portion
        
        # filter events
        if line.find("Masquerade") != -1:
            return
        
        # decompose event
        # bug : this is the destination IP !!
        #a = line.split("->")
        #srcIP = a[1]
        #srcIP = srcIP.lstrip(" ")
        #srcIP = srcIP.split(" ")[0]
        #srcIP = srcIP.split(":")[0]		# remove the port number
        
        # This is the source IP
        a = line.split(">")
        srcIP = a[1]
        srcIP = srcIP.lstrip(" ")
        #srcIP = srcIP.split(" ")[0]
        srcIP = srcIP.split(":")[0]		# remove the port number

        # Anonymise/compress mars honeypot IP address 
        if srcIP == HPOT :
            srcIP = "HPOT"
        
        # Anonymise/compress honeyd IP address
        if srcIP == HONEYD:
            srcIP   = "HPOT"
        
        #print "srcIP = " + srcIP
        
        # bug : is this not working ? do not log honeypot originated packets
        if srcIP == "HPOT" or srcIP == "ROUTER" or srcIP == "192.168.1.131" :
            #print "processp0f returning -> src IP " + srcIP + " is in my network, so ignore..."
            return
        
        #if srcIP == "172.31.0.67" or srcIP == "192.168.1.131" :
            #print "P0f returning -> src IP is my network"
        #    return

        # do not log WHOIS lookups
        if srcIP == "199.212.0.43" or srcIP == "199.71.0.43" or srcIP == "202.12.29.13" or srcIP == "193.0.6.135" :
            return
        
        # fake up flow parameters -> bug -> actually decode the full flow details from the p0f entry
        srcPort = "-1"
        proto   = "-1"
        dstIP   = "p0f"		# spread out the afterglow graph
        dstPort = "-1"
        
        flow = srcIP + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")"               
        #print "flow is " + flow
        
        # extract OS
        a = line.split("-")
        #os = a[1].split(" ")[0]		# only the main type i.e. Linux, Windows, UNKNOWN
        os = a[1].lstrip(" ")
        os = os.split(" ")[0]
               
        event = "OS=" + os
        #event = "p0f,mars,INTEL,"  + line[27:]
        # set to FEED so that the message is not actually Tweeted
        msg = "p0f,mars,FEED,"  + getIntelStr(srcIP,"-1") + "," + flow + "," + event 
        print "p0f        : " + msg
        
        # Log to kojoney_tail.log     
        makeMsg(0,"0",msg)
        
        # Visualise
        sendTweet(msg)
    
        # look for anomalies - make this an email alert ?
        if line.find("BSD") != -1 or line.find("Cisco") != -1 or line.find("MacOS") != -1 or line.find("SunOS") != -1 :
            syslog.syslog("p0f detected unusual OS : " + line)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processp0f() exception caught = " + `e` + "line=" + line)

# Process Apache error log 
# todo : extract src IP and preform getInteStr() on it
# initial version just copies error event to Kojoney_tail.py
def processWeb(line):
    
    sensorName = "mars"
            
    try:     
        line = line.strip("\n")     
        #print "web        : " + line	
        
        # log anything with an IP address in it 
        if line.find("client") != -1:
            a = line.split("[")[3]
            #print "processWeb() : " + a
            # a = client 192.168.1.248] File does not exist: /srv/httpd/htdocs/evilhaxxor7
            srcIP = a.split(" ")[1]
            #print "srcIP is " + srcIP
            srcIP = srcIP.rstrip("]")
            #print "srcIP is " + srcIP
            
            # Extract the error message
            error = a.split(" ")
            error = " ".join(error[2:])
        
            # Get OS type    
            p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",HPOT,"80");		# 0 = wildcard the srcPort
            if p0fInfo['result'] == True :				# p0f data is available
                os   = p0fInfo['genre']
                nat  = p0fInfo['nat'][0]				# 'y' not 'yes'
            else:
                os  = "?"
                nat = "?"
        
            # fake up flow parameters
            srcPort = "-1"
            proto   = "-1"
            dstIP   = HPOT						# bug : what if it is honeyd on different IP ?
            dstPort = "80"
        
            flow = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + ",IN"               
            #print "flow is " + flow
         
            # Calling it a FEED means that a Tweet will not be sent 
            event = "web" + "," + sensorName + "," + "RECON,"  +  getIntelStr(srcIP,"-1") + "," + flow + ",event=" + '"' + error + '"'
            #print "web        : " + event	
        
            # Log to Channel      
            makeMsg(0,"0",event)
            
            # Visualise
            sendTweet(event)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processWeb() exception caught = " + `e` + "line=" + line)

# AAA Authentication 
# contains successful and failed logins
# there is also a login attempt message in the syslog
# add flow information
# need to add enable processing
def processaaa(line):
    
    try:            
        line=line.strip("\n")
        print "Aaa        : " + line	
                
        # events to ignore
        if line.find("login attempt") != -1:
            return 	
        if line.find("error reading fd") != -1:
            return 	
        
        # login OK
        if line.find("login successful") != -1 :
            fields=line.split(" ")
            #print fields
            a = fields[7]		# user=fred
            #print a
            user = a.split("=")[1]
            b = fields[11]		# srcIP
            #print b
            srcIP = b.split("=")[1]	# userIP=x.x.x.x
            
            event = "cli,router,EXPLT," + getIntelStr(srcIP,"-1") + "," + srcIP + ",(-1),[6],ROUTER,(22/23)," + "AUTH_OK,"  + user
            print "aaA      : " + event
            # Log to kojoney_tail.log & send Tweet     
            makeMsg(0,"0",event)
            sendTweet(event)
    
        # login failed
        # todo - extract password the haxxor tried to use
        if line.find("login failed") != -1:
            fields=line.split(" ")
            #print fields
            a = fields[7]		# user=fred
            #print a
            user = a.split("=")[1]
            b = fields[12]		# srcIP
            #print b
            srcIP = b.split("=")[1]	# userIP=x.x.x.x
            
            #print "Aaa      : user failed authentication : " + user + " haxxorIP is " + srcIP
        
            #print fields
        
            event = "cli,router,EXPLT," + getIntelStr(srcIP,"-1") + "," + srcIP + ",(-1),[6],ROUTER,(22/23)," + "AUTH_FAIL,"  + user	
            print "Aaa      :" + event   
            # Log to kojoney_tail.log & send Tweet     
            makeMsg(0,"0",event)
            sendTweet(event)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processaaa() [authentication] exception caught = " + `e` + "line=" + line)

# AAA Accounting 
def processaaaa(line):
    
    try:            
        line=line.strip("\n")
        print "aaA          : " + line	
                
        # Return if can't find "cmd=" in the message
        if line.find("cmd=") == -1:
            return
        
        # events to ignore
        fields = line.split("\t")
        print fields
        
        cli = fields[11]	# command the haxxor entered
        srcIP = fields[4]	# the haxxor IP
        user  = fields[2]       # username used by haxxor
        
        # _> represents level1 Cisco user, extend this to USER_# when enable user decode has been written
        event = "cli,router,USER_>," + getIntelStr(srcIP,"-1") + "," + srcIP + ",(-1),[6],ROUTER,(22/23)," + user + "@RTR> " + cli 
               
        # Log to kojoney_tail.log & send Tweet     
        makeMsg(0,"0",event)
        sendTweet(event)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processaaaa() [accounting] exception caught = " + `e` + "line=" + line)

# Process dns log from Malware hosting system DNSmasq sending syslog to /var/log/debug
# todo : extract src IP and preform getInteStr() on it
# This file is also processed by kojoney_viz.py - i.e. the code is virtualy identical
UniqueDNS = {}
               
def processdns(line):
    global UniqueDNS
            
    try:                
        line=line.strip("\n")
        print "dns          : " + line	

        if line.find("dnsmasq[") != -1 :
            if line.find("whois.cymru.com")  != -1:	# ignore
                return
            if line.find("whois.ripe.net")   != -1:	# ignore
                return
            if line.find("whois.arin.net")   != -1:	# ignore
                return
            if line.find("whois.afrinic.net")   != -1:	# ignore
                return
            if line.find("whois.apnic.net")  != -1:	# ignore
                return
            if line.find("whois.lacnic.net") != -1:	# ignore
                return
            if line.find("whois.nic.ad.jp") != -1:	# ignore
                return
            if line.find("whois.nic.or.kr") != -1:	# ignore
                return
            if line.find("twitter.com")      != -1:	# ignore
                return    
            if line.find("NXDOMAIN-IPv4")    != -1:	# ignore No Name responses
                return
            if line.find("NXDOMAIN-IPv6")    != -1:	# ignore No Name responses
                return
            if line.find("NODATA-IPv6")      != -1:	# ignore No Name responses
                return            
            if line.find("obmr.btconnect.com") != -1:	# ignore BT Connect e-mail
                return
                
            # Log interesting DNS replies    
            if line.find("reply") != -1 or line.find("cached") != -1:
                a = line.split(" ")
                name = a[6]
                ip   = a[8]
                print "dns        : " + name + " resolved to " + ip
                #print "dns        : " + line[36:].strip("\n")

                # has this name->IP pair been seen before ?
                dnsPair = name + "," + ip
            
                if UniqueDNS.has_key(dnsPair) == False :
                    print "unique DNS pair, add to file : " + dnsPair
                    UniqueDNS[dnsPair] = 1
                    # log unique name -> IP mappings to a file for Afterglow post-processing - this file must have been touched
                    fpOut = open(r'/home/var/log/kojoney_dns.csv','a')
                    print >> fpOut,dnsPair 
                    fpOut.close()
                #else:
                #    print "DNS pair has been seen before, so ignore : " + dnsPair
                
                #event = "dns,mars,INTEL,"  + line[36:].strip('\n')
                # Do not log to kojoney_tail.log -> too much info at the moment     
                #makeMsg(0,"0",event)
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processdns() exception caught = " + `e` + "line=" + line)

#
# Examples
# Jan  4 20:40:00 mars Amun[1302]: Exploit: 217.19.124.31 -> 172.31.0.67:135 DCOM Vulnerability (cbackf://217.19.124.31:13113/D2INhw==)
# Jan  4 23:29:49 mars Amun[1302]: Exploit: 217.197.245.182 -> 172.31.0.67:135 DCOM Vulnerability (None)
# Jan  4 23:29:49 mars Amun[1302]: Exploit: 217.197.245.182 -> 172.31.0.67:135 DCOM Vulnerability (tftp://217.197.245.182:69/ssms.exe)
# Jan  4 23:35:17 mars Amun[1302]: Exploit: 217.196.68.35 -> 172.31.0.67:135 DCOM Vulnerability (None)
# Jan  4 23:44:08 mars Amun[1302]: Exploit: 217.113.131.20 -> 172.31.0.67:135 DCOM Vulnerability (None)
def processAmunSyslog(line):
        
    try:
        #print "processAmunSyslog() : line read from Amun syslog : " + line + "\n"
        line=line.strip('\n')	# remove trailing \n
    
        if line.find("mars Amun") == -1 :
            return
            
        # Parse
        # -----    
        fields=line.split(" ")
        #print fields    
        
        srcIP   = fields[7]
        dstIP   = fields[9].split(":")[0]
        srcPort = "-1"							# not present in the syslog
        dstPort = fields[9].split(":")[1]
        proto   = "?"
        event   = '"' + fields[6] + " ".join(fields[10:]) + '"'		# e.g. "Exploit:DCOM Vulnerability (None)"    
        
        # Get OS type of SRC IP    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);		# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :					# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat'][0]
        else:
            os =  "?"
            nat = "?"
        
        # Anonymise/compress honeypot IP address
        if srcIP == HPOT:
            srcIP   = "HPOT"
      
        if dstIP == HPOT:
            dstIP = "HPOT"
        
        direction = "IN"					# Hard-coded
        
        # Build standard fields
        flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + "," + direction
        
        msg = "amun" + "," + "mars"+ "," + "EXPLOIT" + "," + getIntelStr(srcIP,dstIP) + "," + flow1 + ",event=" + event 	
        makeMsg(0,"0",msg)	
        sendTweet(msg)
            
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processAmunSyslog() exception caught = " + `e` + "line=" + line)

# /var/log/messages
#May 10 06:48:30 mars sshd[1122]: Accepted password for test from 172.31.0.68 port 1028 ssh2 
#May 10 08:52:50 mars sshd[1291]: Failed password for test from 172.31.0.68 port 1029 ssh2 
#May 10 08:52:52 mars sshd[1291]: Accepted password for test from 172.31.0.68 port 1029 ssh2 
#May 10 14:26:15 mars sshd[9525]: Accepted password for crouchr from 192.168.1.248 port 49918 ssh2
def processMessages(line):
        
    try:
        print "processMessages() : line read from /var/log/messages : " + line + "\n"
        line=line.strip('\n')		# remove trailing \n
    
        if line.find("from 192.168.1.") != -1 :		# do not log legitimate local LAN access 
            return
        if line.find("mars sshd") == -1 :
            return
        if line.find("Accepted password for") == -1 :
            return
 
        # Parse
        # -----    
        pat = r'\d+\.\d+\.\d+\.\d+'  		# locate a number of IP addresses
        ips = re.findall(pat,line)     
        
        fields=line.split(" ")
        print fields				# locate username
        username = fields[8]    
        
        srcIP   = ips[0]
        dstIP   = "HPOT"
        srcPort = "-1"							# not present in the syslog
        dstPort = "22"
        proto   = "6"							# TCP
        event   = "user=" + username					# todo : parse the user	    
        
        # Get OS type of SRC IP    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);		# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :					# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat'][0]
        else:
            os =  "?"
            nat = "?"

        direction = "IN"					# Hard-coded

        # Get DNS info
        dnsInfo = ipintellib.ip2name(srcIP)
        dnsName = dnsInfo['name'].rstrip('.')			# right-strip the trailing .
        
        # WHOIS : primary information
        # Some confusion about which library to use for ip to AS info tranlsation
        #asInfo = rch_asn_funcs.ip2asn(ip)				# need to add routes=1 to get ASN - timeout bug at moment
        asInfo = ipintellib.ip2asn(srcIP)				# 
        asNum = asInfo['as']					# AS123 
        asRegisteredCode = asInfo['registeredCode']			# Short-form e.g.ARCOR
        #countryCode = asInfo['countryCode']			# Slower than GeoIP
        #print "getIntelStr(" + ip + ") : " + asNum + " " + asRegisteredCode
        
        # WHOIS info gathered from "infos" fields
        #info        = asInfo['info']
        #purpose     = asInfo['purpose']
        #vodafone    = asInfo['vodafone']
        
        # GeoIP information - faster than WHOIS for looking up Country Code information
        geoIP = ipintellib.geo_ip(srcIP)				
        countryCode = geoIP['countryCode']
        city        = geoIP['city']
        longitude   = geoIP['longitude']				# Used to calc approx. localtime
        latitude    = geoIP['latitude']				

        # Build standard fields
        flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + "," + direction
        
        msg = "sshd" + "," + "mars"+ "," + "USER" + "," + getIntelStr(srcIP,dstIP) + "," + flow1 + ",event=" + event 	
        print "processMessages() : " + msg
        
        makeMsg(0,"0",msg)	
        sendTweet(msg)

        # Send alert e-mail
        #email = "An intruder has successfully logged into the honeypot :-\n\n" + "intruder IP=" + srcIP + "\n" + "user=" + username + "\n" + 
        email = "An intruder has successfully logged into the honeypot :-\n" + \
        "\nusername  : " + username + \
        "\nIP        : " + srcIP +  \
        "\nDNS       : " + dnsName +  \
        "\nWHOIS     : " + asNum + " (" + asRegisteredCode + ")" + \
        "\nGeoIP     : " + countryCode + " " + city + " " + "%.2f" % longitude + " East" + \
        "\nOS  (p0f) : " + os + \
        "\nNAT (p0f) : " + nat
        
        #+ ",fw=" + fw + ",nat=" + nat + ",bteh=" + `bteh`\
        #+ "," + username + "@hpot$ " + cli
        
        print "------------"
        print email
        print "------------"
        statusAlert("haxx0r logged in successfully from " + countryCode + " !",email)
        playAlert.playAlert(3)			# play Defcon 3 MP3 sound on botwall machine
                
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processMessages() exception caught = " + `e` + "line=" + line)


# TCP  : Jan  4 07:19:49 mars honeyd[10158]: 2010-01-04:07-19-49:tcp(6):PROBE:192.168.1.131 48081 172.31.0.1 1863:60: S:genre=Linux:2.6 (newer, 1):hops=1:linktype=ethernet/modem:tos=0:uptime(hrs)=29617493:masq-score=-3% (flags 4000):firewall=no:NAT=yes:realOS=1: 
# ICMP : Jan  5 06:52:28 mars honeyd[10158]: 2010-01-05:06-52-28:icmp(1):PROBE:192.168.1.131 172.31.0.1 8(0):84:N/A:OS detection not possible
def processHoneydSyslog(line):
        
    try:
        #print "processHoneydSyslog() : line read from Honeyd syslog : " + line + "\n"
        line=line.strip('\n')			# remove trailing \n
        line=line.rstrip(':')			# remove trailing : from Honeyd log -> probably a bug...
    
        if line.find("mars honeyd") == -1 :
            return
        
        if line.find("arp reply") != -1 :	# ignore this event
            return
        
        # Parse
        # -----    
        fields=line.split(":")
        #print fields    
        
        proto   = fields[5].split('(')[1].rstrip(')')
        event   = ",".join(fields[8:])				# Bit clunky but log the additional info as unparsed fields for time being    
        #print "event is " + event 
        
        type = "HD_" + fields[6]				# HD = short version of HoneyD
        
        if proto == "1" :
            #print "honeyd : icmp"
            srcIP = fields[7].split(" ")[0]
            dstIP = fields[7].split(" ")[1]
            srcPort = "-1"
            dstPort = "-1"					# todo : pull out ICMP type and code -> they are present
        else:
            srcIP   = fields[7].split(" ")[0]
            srcPort = fields[7].split(" ")[1]
            dstIP   = fields[7].split(" ")[2]
            dstPort = fields[7].split(" ")[3]
        
        # Get OS type of SRC IP    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);	# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :				# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat'][0]
        else:
            os =  "?"
            nat = "?"
        
        # Anonymise/compress honeypot IP address
        if srcIP == HONEYD:
            srcIP = "HPOT"
      
        if dstIP == HONEYD:
            dstIP = "HPOT"
        
        direction = "IN"					# Hard-coded
        
        # Build standard fields
        flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + "," + direction
        
        # not sure what to call this -> use PROBE for the time being
        msg = "honeyd" + "," + "mars"+ "," + type + "," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + event 	
        #print msg
        makeMsg(0,"0",msg)	
        sendTweet(msg)
            
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processHoneydSyslog() exception caught = " + `e` + "line=" + line)

# Write netflow events to a file
def logNetflowEvent(msg):
    fp = open(r'/home/var/log/netflow_events.log',"a")
    print >> fp,msg
    fp.close()
    print "**** Logged netflow event to file : " + msg
         
# Process Netflows log entries
# Look for initial reconnaisance
# i.e. NMAP pings etc
# TODO : add Nmap scan but only if dest is 172.31.0.67:22
# TODO : dump never seen before messages to a text file
#
#*** NEW EVENT in raw netflows (all sources) logfile to process !
#processFlows() : line read from Flows file : Nov 11 06:39:21 mars netflow-bg_rtr: rtr=bg_rtr srcIP=172.30.0.2 srcPort=65330 dstIP=192.168.1.131 dstPort=53 proto=17 bytes=61 pkts=1 inIf=2 outIf=1 flags=16 start=1518379502 end=1518379502 min_plen=0 max_plen=0 minTTL=0 maxTTL=0 IP_ID=0 opt=0 fwd=0 fragFlags=0 fragOffset=0 header=none payload=none
#
#['Nov', '11', '06:39:21', 'mars', 'netflow-bg_rtr:', 'rtr=bg_rtr', 'srcIP=172.30.0.2', 'srcPort=65330', 'dstIP=192.168.1.131', 'dstPort=53', 'proto=17', 'bytes=61', 'pkts=1', 'inIf=2', 'outIf=1', 'flags=16', 'start=1518379502', 'end=1518379502', 'min_plen=0', 'max_plen=0', 'minTTL=0', 'maxTTL=0', 'IP_ID=0', 'opt=0', 'fwd=0', 'fragFlags=0', 'fragOffset=0', 'header=none', 'payload=none']
#number of fields is 29
#fields[0] : Nov
#fields[1] : 11
#fields[2] : 06:39:21
#fields[3] : mars
#fields[4] : netflow-bg_rtr:
#fields[5] : rtr=bg_rtr
#fields[6] : srcIP=172.30.0.2
# 29 fields
def processFlows(line):
    
    try:            
        line=line.strip('\n')	# remove trailing \n
        print "processFlows() : line read from Flows file : " + line + "\n"
        
        # Parse Netflow
        # -------------    
        fields=line.split(" ")
        print fields    
        numFields = len(fields)
        print "number of fields is " + `numFields`
        
        if numFields != 29:
            msg =  "error ! number of fields is " + `numFields` + ", expected number is 29"   
            syslog.syslog("kojoney_tail.py : processFlows() : " + msg + " " + line)

        print "fields[0] : " + fields[0]
        print "fields[1] : " + fields[1]
        print "fields[2] : " + fields[2]
        print "fields[3] : " + fields[3]
        print "fields[4] : " + fields[4]
        print "fields[5] : " + fields[5]
        print "fields[6] : " + fields[6]

        a,rtr = fields[5].split("=")
        #a,rtr = fields[6].split("=")
        print "rtr is " + rtr
    
        a,srcIP = fields[6].split("=")
        print "srcIP is " + srcIP
    
        a,srcPort = fields[7].split("=")
        #print "srcPort is " + srcPort
    
        a,dstIP = fields[8].split("=")
        #print "dstIP is " + dstIP
    
        a,dstPort = fields[9].split("=")
        #print "dstPort is " + dstPort
    
        a,proto = fields[10].split("=")
        #print "proto is " + proto
    
        a,bytes = fields[11].split("=")
        #print "bytes is " + bytes
    
        a,pkts  = fields[12].split("=")
        #print "pkts is " + pkts
            
        a,inIf   = fields[13].split("=")
        #print "inIf is " + inIf
    
        a,outIf  = fields[14].split("=")
        #print "outIf is " + outIf
      
        a,flags    = fields[15].split("=")
        #print "flags = " + flags
        
        a,start = fields[16].split("=")
        #print "start = " + start
        
        a,end = fields[17].split("=")
        #print "end   = " + end
        
        a,min_plen = fields[18].split("=")
        #print "min_plen = " + min_plen
        
        a,max_plen = fields[19].split("=")
        #print "max_plen = " + max_plen
        
        a,minTTL   = fields[20].split("=")
        #print "minTTL = " + minTTL
        
        a,maxTTL   = fields[21].split("=")
        #print "maxTTL = " + maxTTL
        
        a,IP_ID    = fields[22].split("=")
        print "IP_ID = " + IP_ID
        
        a,header  = fields[27].split("=")
        #print "header = " + header
        
        a,payload  = fields[28].split("=")
        #print "payload = " + payload
        
        decodedPayload = decodeSection(payload)
        #print "payload is " + decodedPayload
        
        #if decodedPayload.find("PING") != -1:
        #    print "#1 Found PING in payload"
                
        # Derived flow parameters
        #print "derived values :-"
        avg = int(bytes)/int(pkts)		# Average packet size
        duration_msecs = int(end) - int(start)
        #print "duration_msecs = " + `duration_msecs`
        
        # Enable some rules to flag up high pps, bps
        # 1. Could mean a file transfer
        # 2. to detect outbound DoS attacks for when running high-interaction honeypot
        if duration_msecs < 500 or int(pkts) < 20 :
            kbps = 0
        else:
            # -> crashes : kbps = "%.1f" % float(bytes)/float(duration_msecs)	    
            kbps = (8 * float(bytes))/(float(duration_msecs) * 1000)	    
        
        if duration_msecs < 500 or int(pkts) < 20 :
            pps = 0
        else:
            #pps = "%.1f" % float(pkts)/(float(duration_msecs) / 1000)   
            pps = float(pkts)/(float(duration_msecs) / 1000)   

        # temp hack until pps and bps are fixed to not have decimal places
        kbps = 0
        pps  = 0
        
        #print "kbps = " + `kbps`
        #print "pps  = " + `pps`
        
        ttlRange = int(maxTTL) - int(minTTL)

        if proto != "6" :	# TCP is only protocol relevent for flags
            flags = "0"
        flagStr = netflowFlags(int(flags))
            
        # Ignore DNS requests    
        if srcIP.find("194.72.6.57") != -1 or dstIP.find("194.72.6.57") != -1 :
            return

        # write to a file to be parsed by SEC
        secFlow = "flow:s=" + srcIP + " sp=" + srcPort + " d=" + dstIP + " dp=" + dstPort + " p=" + proto + " f=" + netflowFlags(int(flags)) + " o=" + outIf
        #print "secFlow is " + secFlow
        writeFlow2SEC(secFlow);
        
        # Get OS type    
        p0fInfo = p0fcmd.getP0fInfo(srcIP,"0",dstIP,dstPort);	# 0 = wildcard the srcPort
        if p0fInfo['result'] == True :				# p0f data is available
            os   = p0fInfo['genre']
            nat  = p0fInfo['nat'][0]
        else:
            os =  "?"
            nat = "?"          
             
        # Anonymise/compress honeypot IP address
        if (srcIP == HPOT or srcIP == MWARE) :
            srcIP   = "HPOT"
      
        if (dstIP == HPOT or dstIP == MWARE) :
            dstIP = "HPOT"
        
        # Anonymise/compress honeyd IP address
        if srcIP == HONEYD:
            srcIP   = "HPOT"
        if dstIP == HONEYD:
            dstIP = "HPOT"
        
        # Anonymise/compress router IP address
        if srcIP == ROUTER:
            srcIP   = "ROUTER"
      
        if dstIP == ROUTER:
            dstIP = "ROUTER"
        
        # Calculate direction of flow
        if inIf == "2":
            direction = "OUT"
        else:
            direction = "IN"   
        
        if proto == "1": 	# ICMP
            print "***** ICMP ***** " + srcIP + "->" + dstIP
            icmpStr = icmpDecode(int(dstPort))
            flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + icmpStr + ")" + "," + direction
        else:
            flow1 = srcIP + "," + os + "{" + nat + "}" + ",(" + srcPort + "),[" + proto + "]," + dstIP + ",(" + dstPort + ")" + "," + direction
        
             
        if proto == "6" :	# TCP
            flagStr = netflowFlags(int(flags))
            flow2 = "F=" + flagStr + ",B=" + bytes + ",D=" + `duration_msecs` + ",P=" + pkts + ",AVG=" + `avg` + ",KBPS=" + "%.1f" % kbps + ",PPS=%.1f" % pps + ",inIf=" + inIf + ",outIf=" + outIf + ",min_plen=" + min_plen + ",max_plen=" + max_plen + ",minTTL=" + minTTL + ",maxTTL=" + maxTTL + ",ipid=" + IP_ID + ",rawPayload=" + payload + ",ASCIIpayload=" + decodedPayload
        else : 			# TCP flags are not relevent, so use "*" to denote this
            flow2 = "*"            + ",B=" + bytes + ",D=" + `duration_msecs` + ",P=" + pkts + ",AVG=" + `avg` + ",KBPS=" + "%.1f" % kbps + ",PPS=%.1f" % pps + ",inIf=" + inIf + ",outIf=" + outIf + ",min_plen=" + min_plen + ",max_plen=" + max_plen + ",minTTL=" + minTTL + ",maxTTL=" + maxTTL + ",ipid=" + IP_ID + ",rawPayload=" + payload + ",ASCIIpayload=" + decodedPayload
     
     
        #print "flow1 is " + flow1
        #print "flow2 is " + flow2
        
        # Under development : Log dropped traffic i.e. outIf is 0
        #if outIf == 0:
        #    msg = "flow," + rtr + ",FEED," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "Dropped" + "," + flow2 
        #    makeMsg(0,"0",msg)	
        #    sendTweet(msg)
        
        # Calculate direction of flow
        #if inIf == "2":
        #    direction = "IN"
        #else:
        #    direction = "OUT"   
        
        #print "#2 decoded payload is " + decodedPayload
        
        # Do not log WHOIS requests
        if (srcPort == "43" or dstPort == "43" or dstPort == "4321" or dstPort == "4321") :	# bug - this is Whois port
            #print "netflow    : ignoring WHOIS query " + flow
            return
        
        # Do not log Twitter requests
        if (proto == "6" and (dstIP.find("168.143.161.") != -1 or dstIP.find("168.143.162.") != -1 or dstIP.find("168.143.171.") != -1 or dstIP.find("128.121.") != -1 or dstIP.find("128.130.") != -1) or dstIP.find("128.242.") != -1) :
            #print "netflow    : ignoring Twitter / Sandbox APIs " + flow
            return
        if (proto == "6" and (srcIP.find("168.143.161.") != -1 or srcIP.find("168.143.162.") != -1 or srcIP.find("168.143.171.") != -1 or srcIP.find("128.121.") != -1 or srcIP.find("128.130.") != -1) or srcIP.find("128.242.") != -1) :
            #print "netflow    : ignoring Twitter / Sandbox APIs " + flow
            return

        # Ignore netflow from router honeypot to honeypot
        if (srcIP == "ROUTER" and dstIP == "HPOT" and dstPort == "9999" and proto == "17") :	
            return
        
        # Ignore NTP
        if (srcPort == "123" and dstPort == "123" and proto == "17") :	
            return
        
        # Ignore netflow from ibg router to honeypot
        if (srcIP == IBG and dstIP == "HPOT" and dstPort == "9990" and proto == "17") :	
            return
            
        # Special case of LAN traffic : AAA between node 7 and mars (AAA)
        if (srcIP == "ROUTER" and dstIP == "HPOT" and dstPort == "49" and proto == "6") :	
            msg = "flow," + rtr + ",AAA," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "ROUTER_AAA"
            makeMsg(0,"0",msg)	
            #sendTweet(msg)
        
        # Ignore all flows to/from the local LAN - but not the node9 or Amun
        if (srcIP.find("192.168.1.") != -1 or dstIP.find("192.168.1.") != -1) and srcIP.find(ROUTER) == -1 and srcIP.find(MWARE) == -1 :
        #if (srcIP.find("192.168.1.") != -1 or dstIP.find("192.168.1.") != -1) :
            print "Local LAN traffic -> ignore"
            return
        
        # ignore flows from router honeypot to mars (e.g. netflow)
        # todo - add destination port to ignore (netflow)/tacacs ?
        if (srcIP.find("ROUTER") != -1 and dstIP.find("HPOT") != -1) :
            print "router honeypot to mars traffic - ignore"
            return
                    
        msg = "flow" + "," + rtr + "," + "FEED" + "," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "netflow" + "," + flow2 	
        # FEED = normalised data
        print "netflow    : " + msg 	
        
        # hack to call up secviz5() - too many flow entries i.e. return traffic - need a better algorithm
        #sendTweet(msg)
        
        #print "#3 decoded payload is " + decodedPayload

        # Write all valid netflow payloads to a file to search later on
        if decodedPayload.find("***NONE***") == -1 :
            now = time.time()
            #nowLocal = time.gmtime(now)  
            nowLocal = time.localtime(now)
            msg = time.asctime(nowLocal) + "   " + srcIP + ":" + srcPort + " -> " + dstIP + ":" + proto + ":" + flagStr + ":" +dstPort + " " + decodedPayload.rstrip()
            print "kojoney_tail.py() : " + msg
            
            fpDecode = open(r'/home/var/log/netflow-dpi.log',"a")
            print >> fpDecode,msg
            fpDecode.close()
        
        # Signatures
        # ----------
        # SQL Slammer
        if (dstIP == "HPOT" and proto == "17" and dstPort == "1434" and int(bytes) == 404):
            msg = "flow," + rtr + ",EXPLT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SQLslammer" + "," + flow2 
            makeMsg(0,"0",msg)	
            sendTweet(msg)
            
        # Anomalous behaviour detection
        # -----------------------------
        # Note that Tweet API uses port 80 so do not log that !
        #
        
        # Case #0 : Outbound DoS attack : duration > 10 secs and (kbps > 50.0 or pps > 500) 	
        #if (srcIP == "HPOT" and int(duration_msecs) > 10000 and int(pkts) > 5000 and (kbps > 600.0 or pps > 500.0) ) :	
        #if (srcIP == "HPOT" and int(duration_msecs) > 10000 and int(pkts) > 10 and (kbps > 10 or pps > 10) ) :	
        #if (srcIP == "HPOT" and int(duration_msecs) > 10000 and int(pkts) > 10 and int(pps) > 1000) :	
        
        # MASTER for SEC processing #2
        if (srcIP == "HPOT") :	
            msg2 = rtr + ":" + "FLOW-OUT from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 
            logNetflowEvent(msg2)
            kojoney_funcs.logDefconEvent(msg2)
            #sendTweet(msg)
            # send an email as well !!!
            #writeSecViz4(srcIP,srcPort,"172.31.0.67","22","EXPL:flw:SSH_session")
        
        # MASTER for SEC processing #2
        if (dstIP == "HPOT") :	
            msg2 = rtr + ":" + "FLOW-IN from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps`
            logNetflowEvent(msg2)
            #syslog.syslog(msg2)
                
        if (srcIP == "HPOT" and int(duration_msecs) > 2000 and int(pkts) > 100 and (kbps > 2 or pps > 5) ) :	
            msg = "flow," + rtr + ",FLOOD," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "OutboundDoS" + "," + flow2 
            makeMsg(0,"0",msg)	
            msg2 = "FLOW,FLOOD-OUT from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` + " proto=" + proto + " src_port=" + srcPort + " flags=" + flags 
            logNetflowEvent(msg2)
            #sendTweet(msg)
            # send an email as well !!!
            #writeSecViz4(srcIP,srcPort,"172.31.0.67","22","EXPL:flw:SSH_session")
        
        # Case #1 : Inbound DoS attack : duration > 10 secs and (kbps > 50.0 or pps > 500) 	
        if (dstIP == "HPOT" and int(duration_msecs) > 10000 and int(pkts) > 5000 and (kbps > 600.0 or pps > 500.0) ) :	
            msg = "flow," + rtr + ",FLOOD," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "InboundDoS" + "," + flow2 
            makeMsg(0,"0",msg)	
            logNetflowEvent(msg)
            #msg2 = "FLOW,FLOW-DETAILS from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` + " proto=" + proto + " src_port=" + srcPort + " flags=" + flags 
            sendTweet(msg)
            
        elif (dstIP == "ROUTER" and int(duration_msecs) > 10000 and int(pkts) > 5000 and (kbps > 600.0 or pps > 500.0) ) :	
            msg = "flow," + rtr + ",FLOOD," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "InboundDoS" + "," + flow2 
            makeMsg(0,"0",msg)
            logNetflowEvent(msg)	
            sendTweet(msg)
        
        # Case #2 : Extract SSH flows that are long enough not to be probes / SSH brute force attempts
        # SSH flow towards honeypot with duration > 4 minutes
        elif (dstIP == "HPOT" and dstPort == "22" and int(duration_msecs) > 240000 and proto == "6") :	
            msg = "flow," + rtr + ",EXPLT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH>4m" + "," + flow2 
            makeMsg(0,"0",msg)	
            sendTweet(msg)
            writeSecViz4(srcIP,srcPort,"172.31.0.67","22","EXPL:flw:SSH_session")
        # SSH flow towards honeypot with duration > 2 minutes 
        elif (dstIP == "HPOT" and dstPort == "22" and int(duration_msecs) > 120000 and proto == "6") :	
            msg = "flow," + rtr + ",EXPLT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH>2m" + "," + flow2 
            makeMsg(0,"0",msg)	
            sendTweet(msg)
            writeSecViz4(srcIP,srcPort,"172.31.0.67","22","EXPL:flw:SSH_session")
        # SSH flow towards honeypot with duration > 30 seconds
        elif (dstIP == "HPOT" and dstPort == "22" and int(duration_msecs) > 30000 and proto == "6") :	
            msg = "flow," + rtr + ",EXPLT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH>30s" + "," + flow2 
            makeMsg(0,"0",msg)	
            sendTweet(msg)
            writeSecViz4(srcIP,srcPort,"172.31.0.67","22","EXPL:flw:SSH_session")
        elif (dstIP == "ROUTER" and dstPort == "22" and int(duration_msecs) > 5000 and proto == "6") :	
            msg = "flow," + rtr + ",EXPLT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH>5s" + "," + flow2 
            makeMsg(0,"0",msg)	
            sendTweet(msg)
            writeSecViz4(srcIP,srcPort,"ROUTER","22","EXPL:flw:SSH_session")
        
        # Case #3 : Telnet towards honeypot router with duration > 5 secs
        elif (dstIP == "ROUTER" and dstPort == "23" and int(duration_msecs) > 5000 and proto == "6") :	
            msg = "flow," + rtr + ",EXPLT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "Telnet>5s" + "," + flow2 
            makeMsg(0,"0",msg)	
            sendTweet(msg)
            writeSecViz4(srcIP,srcPort,"ROUTER","23","EXPL:flw:Telnet_session")
        
        # Case #4 : ICMP towards honeypot(s)
        # todo : unreachables ?
        elif (dstIP == "HPOT" and proto == "1") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "ICMP" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif (dstIP == "ROUTER" and proto == "1") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "ICMP" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif (dstIP == "HPOT" and proto == "1") :	
            msg = "FLOW,ICMP from " + srcIP + " to " + dstIP + " typeCcode " + dstPort 
            #logNetflowEvent(msg)
            sendTweet(msg)
        
        # Case #5 : ICMP from honeypot(s)
        elif (srcIP == "HPOT" and proto == "1") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "ICMP" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif (srcIP == "ROUTER" and proto == "1") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "ICMP" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #6 : SSH and Telnet sessions - i.e. the brute force attempts
        elif (dstIP == "HPOT" and dstPort == "22") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH" + "," + flow2
            makeMsg(0,"0",msg)
            return
        elif (dstIP == "HPOT" and dstPort == "23") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TELNET" + "," + flow2
            makeMsg(0,"0",msg)
            return
        elif (dstIP == "ROUTER" and dstPort == "22") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SSH" + "," + flow2
            makeMsg(0,"0",msg)
            return
        elif (dstIP == "ROUTER" and dstPort == "23") :	
            msg = "flow," + rtr + ",RECON," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TELNET" + "," + flow2
            makeMsg(0,"0",msg)
            return    
        
        # Case #7 : Malware retrieval using port 80 (HTTP) / 443 from external IP 
        elif (srcIP == "HPOT" and dstPort == "80" and proto == "6") :
            msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "HTTP_XFER" + "," + flow2
            makeMsg(0,"0",msg)
            msg = "FLOW,HTTP from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg)
            sendTweet(msg)
            
        elif (srcIP == "HPOT" and dstPort == "443" and proto == "6") :
            msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "HTTPS_XFER" + "," + flow2
            makeMsg(0,"0",msg)
            msg = "FLOW,HTTPS from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg)
            sendTweet(msg)
        
        elif (srcIP == "HPOT" and (int(dstPort) >= 6667 and int(dstPort) <= 7000 ) and proto == "6") :
            msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_XFER" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
            #msg = "FLOW,IRC from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #print "**" + msg
            #logNetflowEvent(msg)

        elif (srcIP == "172.30.0.2" and dstPort == "53") :
            msg = "flow," + rtr + ",DNS," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "DNS" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
            #msg = "FLOW,DNS from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #print "**" + msg
            #logNetflowEvent(msg)
        
        elif (dstIP == "HPOT" and dstPort == "113" and proto == "6") :
            #msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "HTTPS_XFER" + "," + flow2
            #makeMsg(0,"0",msg)
            msg = "FLOW,FINGER from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg)
            sendTweet(msg)
                   
        # Case #8 : Malware retrieval using port 21 (FTP) from external IP
        elif (srcIP == "HPOT" and dstPort == "21" and proto == "6") :
            msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "FTP_XFER" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
            msg = "FLOW,FTP from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg)
        
        # Case #9 : Malware retrieval using port 69 (TFTP) from external IP
        elif (srcIP == "HPOT" and dstPort == "69" and proto == "17") :
            msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TFTP_XFER" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
            msg = "FLOW,TFTP from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg)
        
        elif (srcIP == "ROUTER" and dstPort == "69" and proto == "17") :
            msg = "flow," + rtr + ",REINF," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TFTP_XFER" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
            
        # Case #10 : NetBIOS long-lived sessions - anything longer than 10 seconds (but ignore e-mail alerts)
        elif (srcIP == "HPOT" and int(duration_msecs) > 20000 and (srcPort == "135" or srcPort == "445" or srcPort == "138" or srcPort == "139")) :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "NetBIOS>20s" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
                
        # Case #11 : NetBIOS large amount of data transferred - anything more than 1 Kbytes
        elif (srcIP == "HPOT" and int(bytes) > 4096 and (srcPort == "135" or srcPort == "445" or srcPort == "138" or srcPort == "139")) :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "NetBIOS>4KB" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
                 
        # Case #12 : Generic long-lived sessions from honeypot - anything longer than 20 seconds (but ignore e-mail alerts)
        elif (srcIP == "HPOT" and duration_msecs > 20000 and dstPort != "25") :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "Dur>20s" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif (srcIP == "ROUTER" and duration_msecs > 20000 and dstPort != "25") :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "Dur>20s" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
                
        # Case #13 : Generic large amount of data transferred - anything more than 5 Kbytes
        elif (srcIP == "HPOT" and int(bytes) > 4096 and dstPort != "25") :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TX>4KB" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
            msg = "FLOW,TRANSFER>4KB from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + duration_msecs
            #logNetflowEvent(msg)
                
        elif (srcIP == "ROUTER" and int(bytes) > 4096 and dstPort != "25") :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TX>4KB" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #14 : TCP NULL flags
        elif (dstIP == "HPOT" and flags == "0" and proto == "6") :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TCP_Flags=0" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        elif (dstIP == "ROUTER" and flags == "0" and proto == "6") :
            msg = "flow," + rtr + ",SUSPC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "TCP_Flags=0" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)    
                
        # Case #15 : TCP RST flag only is set
        elif (flags == "4" and proto == "6") :
            msg = "flow," + rtr + ",MISC," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "RST" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #16 : TCP SYN flag only is set
        elif (flags == "2" and proto == "6") :
            msg = "flow," + rtr + ",SYN," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SYN" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #17 : TCP FIN flag only is set
        elif (flags == "1" and proto == "6") :
            msg = "flow," + rtr + ",FIN," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "FIN" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #18 : fragmented traffic
        elif (dstPort == "0") :
            msg = "flow," + rtr + ",FRAG," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "FRAG" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #19 : AR flags set - C = Closed port 
        elif (flags == "20" and proto == "6") :
            msg = "flow," + rtr + ",PROBE_C," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "PROBE_C" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #20 : E-mail data transfer (DTXmail) -> if AP flags set and port is a NetBIOS one
        elif (proto == "6" and flagStr.find("AP") != -1 and (dstPort == "25" or srcPort == "25") ) :
            msg = "flow," + rtr + ",DTXmail," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "DTXmail" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #21 : NetBIOS data transfer (DTXnb) -> if AP flags set and port is a NetBIOS one
        # see lots of brute-force probes here so not worth tweeting
        elif (proto == "6" and flagStr.find("AP") != -1 and (dstPort == "445" or srcPort == "445" or dstPort == "138" or srcPort == "138" or dstPort == "139" or srcPort == "139") ) :
            msg = "flow," + rtr + ",DTXnb," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "DTXnb" + "," + flow2
            makeMsg(0,"0",msg)
            #sendTweet(msg)
        
        # Case #22 : SSH data transfer (DTXssh) -> if AP flags set and port is a SSH one
        # see lots of brute-force probes here so not worth tweeting
        elif (proto == "6" and flagStr.find("AP") != -1 and (dstPort == "22" or dstPort == "22") ) :
            msg = "flow," + rtr + ",DTXssh," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "DTXssh" + "," + flow2
            makeMsg(0,"0",msg)
            #sendTweet(msg)
            
        # Case #23 : "other" data transfer - probably more interesting than NetBIOS DTX which is constantly under attach / abuse
        # add direction (IN/OUT) so that flows can be not added to visualisation if required
        # for botnet monitoring, only want outbound DTX flows
        elif (proto == "6" and flagStr.find("AP") != -1) :
            msg = "flow," + rtr + ",DTX-" + direction + "," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "DTX" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        # Case #24 : minTTL and maxTTL not the same
        elif (ttlRange > 0) :
            msg = "flow," + rtr + ",TTL-anomally," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "ttlRange>0" + "," + flow2
            makeMsg(0,"0",msg)
            sendTweet(msg)
        
        #print "#4 decoded payload is " + decodedPayload
        
        # Case #25a : IRC PING command in payload in netflow
        if decodedPayload.find("PING") != -1  :
            print "Found PING in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_PING," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "PING" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = rtr + ":" + "IRC_PING from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 
            #msg2 = "FLOW-DPI,IRC_PING from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            logNetflowEvent(msg2)
            sendTweet(msg)
                  
        # Case #25b : IRC PING command in payload in netflow
        if decodedPayload.find("PONG") != -1  :
            print "Found PONG in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_PONG," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "PONG" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_PONG from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_PONG from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 
            logNetflowEvent(msg2)
            sendTweet(msg)
            
        # Case #25c : IRC USERHOST command in payload in netflow
        if decodedPayload.find("USERHOST") != -1  :
            print "Found USERHOST in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_USERHOST," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "USERHOST" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_USERHOST from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            sendTweet(msg)

        # Case #25d : IRC NICK command in payload in netflow
        if decodedPayload.find("NICK") != -1  :
            print "Found NICK in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_NICK," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "NICK" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_NICK from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_NICK from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 
            logNetflowEvent(msg2)
            sendTweet(msg)
        
        # Case #25e : PRIVMSG command in payload in netflow
        if decodedPayload.find("PRIVMSG") != -1  :
            print "Found PRIVMSG in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_PRIVMSG," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "PRIVMSG" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_NICK from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_PRIVMSG from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 
            logNetflowEvent(msg2)
            sendTweet(msg)

        # Case #25f : IRC JOIN command in payload in netflow
        if decodedPayload.find("JOIN") != -1  :
            print "Found JOIN in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_JOIN," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "JOIN" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_JOIN from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_JOIN from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 
            logNetflowEvent(msg2)
            sendTweet(msg)
        
        # Case #25g : IRC error 
        if decodedPayload.find("Cannot join channel") != -1  :
            print "Cannot join channel : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_ERR_JOINFAIL," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "JOIN_FAIL" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_JOIN_FAIL from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_ERR_JOINFAIL from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 

            logNetflowEvent(msg2)
            sendTweet(msg)
            
        # Case #25h : IRC error 
        if decodedPayload.find("Nickname is already in use") != -1  :
            print "Nickname is already in use : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_ERR_BADNICK," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "BAD_NICK" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_BAD_NICK from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_ERR_BADNICK from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 

            logNetflowEvent(msg2)
            sendTweet(msg)

        # Case #25i : IRC MODE
        # 2r   P   W    Aztlan  Wirikuta Jokerz users undernet org MODE  c0de  l 43   
        if decodedPayload.find("MODE") != -1  :
            print "MODE : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_MODE," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_MODE" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_MODE from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            sendTweet(msg)
        
        # Case #25j : IRC ERROR
        # 2r   P   W    Aztlan  Wirikuta Jokerz users undernet org MODE  c0de  l 43   
        if decodedPayload.find("ERROR") != -1  :
            print "ERROR : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_ERR," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_ERROR" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            #msg2 = "FLOW-DPI,IRC_ERROR from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            msg2 = rtr + ":" + "IRC_ERR from " + srcIP + " to " + dstIP + " proto=" + proto + " dp=" + dstPort + " sp=" + srcPort + " flags1=" + flags + " flags2=" + netflowFlags(int(flags)) + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs` + " kbps=" + `kbps` + " pps=" + `pps` 

            logNetflowEvent(msg2)
            sendTweet(msg)
        
        # Case #25e : IRC MODE
        # BrokenPipe  niggachin 211 44 56 231 QUIT  Ping timeout    
        if decodedPayload.find("Ping timeout") != -1  :
            print "Ping timeout : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_ERR_PINGTIMEOUT," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_PING_TIMEOUT" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_ERR_PINGTIMEOUT from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            sendTweet(msg)
        
        # Case #25e : IRC MODE
        #     nY H               w       PING  2025112805  NOTICE AUTH      No ident response  NOTICE AUTH      Couldn t look up your hos
        #             l   P        Tampa FL US Undernet org 433 BndxvOGT Cristi  Nickname is already in use
        #                 L           w1
        #                      L  L      P            w  4
        #                          N
        #                              M  Q        t
        #                                  NV
        #                                        dQJ5      U       w  o   hNOTICE AUTH      Checking Ident  PING  2858667281  NOTICE AUTH      No ident response  NOTICE AU
        #                                             nY H        d      w       PING  2025112805  NOTICE AUTH      No ident response  NOTICE AUTH      Couldn t look up your hos
        #                                                  L  L       O       w       PING  2840321729  NOTICE AUTH      No ident response  NOTICE AUTH      Couldn t look up your hos  
        if decodedPayload.find("NOTICE AUTH") != -1  :
            print "NOTICE AUTH : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_NOTICE_AUTH," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_NOTICE_AUTH" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_NOTICE_AUTH from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            sendTweet(msg)
        
        #    n ra UDe    V           w  r NICK s3b4 454 USER good      good  
        if decodedPayload.find("NICK") != -1 and decodedPayload.find("USER") != -1  :
            print "NICK & USER : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_CREDENTIALS," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_CREDENTIALS" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_CREDENTIALS from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            # Dump Nick credentials
            msg2 = "FLOW-DPI,SPECIAL_INFO," + decodedPayload
            #logNetflowEvent(msg2)
            sendTweet(msg)
            
        # X  P       PART  botis JOIN  botis    
        if decodedPayload.find("PART") != -1 and decodedPayload.find("JOIN") != -1  :
            print "PART & JOIN : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_PART&JOIN," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_PART&JOIN" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_PART&JOIN from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            # Dump decode for later analysis
            msg2 = "FLOW-DPI,SPECIAL_INFO," + decodedPayload
            #logNetflowEvent(msg2)
            sendTweet(msg)
            
        
        #X      P        sebas1234  Thoday mx01 sfh voicehost co uk QUIT  G lined  AUTO  3   Ar1V2  Infected with a virus or trojan     
        if decodedPayload.find("AUTO") != -1 :
            print "AUTO : found in payload"
            msg = "FLOW-DPI," + rtr + ",IRC_AUTO," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_AUTO" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,IRC_AUTO from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #syslog.syslog(msg2)
            # Dump decode for later analysis
            msg2 = "FLOW-DPI,SPECIAL_INFO," + decodedPayload
            #logNetflowEvent(msg2)
            sendTweet(msg)
        
        #      K o  vP   Ud   ChapoGuzman  paco host217 41 27 169 in addr btopenworld com JOIN  c0de     
        if decodedPayload.find("217 41 27 169") != -1 :
            print "MyIP : found in payload"
            msg = "FLOW-DPI," + rtr + ",MYIP," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "IRC_MYIP" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,MYIP from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            # Dump decode for later analysis
            msg2 = "FLOW-DPI,SPECIAL_INFO," + decodedPayload
            #logNetflowEvent(msg2)
            sendTweet(msg)

            
        # Case #25e : SIP 
        #  OPTIONS sip 100 217 41 27 169 SIP 2 0  Via  SIP 2 0 UDP 192 168 1 9 5060 branch z9hG4bK 77503845 rport  Content Length  
        if decodedPayload.find("SIP") != -1  :
            print "SIP : found in payload"
            msg = "FLOW-DPI," + rtr + ",SIP," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "SIP" + "," + flow2
            makeMsg(0,"0",msg)
            print msg
            msg2 = "FLOW-DPI,SIP from " + srcIP + " to " + dstIP + " on port " + dstPort + " bytes=" + bytes + " pkts=" + pkts + " msecs=" + `duration_msecs`
            #logNetflowEvent(msg2)
            sendTweet(msg)    
            
        
        # Case #26 : all packets in a flow are same length
        #elif (int(pkts) > 1 and int(min_plen) == int(max_plen)) :
        #    msg = "flow," + rtr + ",plen-anomally," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + "plen=" + min_plen + "," + flow2
        #    makeMsg(0,"0",msg)
        #    sendTweet(msg)
        
        # Generic probe
        # Ongoing dilema of whether generic flows should be mapped
        else:
            msg = "flow," + rtr + ",FLOW," + getIntelStr(srcIP,dstIP) + "," + flow1 + "," + flow2
            sendTweet(msg)	# sends record to the Kojoney Channel
            #pass
            print "---> Netflow not interesting, so no event generated..."
    
    #         32 16  8  4  2  1
    # flags : U  A   P  R  S  F
    
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processFlows() exception caught = " + `e` + "line=" + line)

# add try: exception to this
# get intel on not the hpot IP 
def getIntelStr(ip1,ip2):
    
    ip = "0.0.0.0"
    #print "getintelStr() : ip1=" + ip1 + " ip2=" + ip2
    
    try: 
    
        if ip1 == ROUTER :
            ip = ip2
        if ip2 == ROUTER :
            ip = ip1    
        
        if ip1 == 'ROUTER' :
            ip = ip2
        if ip2 == 'ROUTER' :
            ip = ip1    
        
        if ip1 == 'HPOT' :
            ip = ip2
        if ip2 == 'HPOT' :
            ip = ip1    
        
        if ip1 == HPOT :
            ip = ip2
        if ip2 == HPOT :
            ip = ip1    
        
        #if ip1 == 'HPOT' :
        #    ip = ip2
        #if ip2 == 'HPOT' :
        #    ip = ip1    
        
        #if ip1 == HPOT :
        #    ip = ip2
        #if ip2 == HPOT :
        #    ip = ip1    
        
        # Only src IP is relevent to p0f so it sets ip2 to "-1"        
        if ip2 == "-1" :
            ip = ip1        
                
        #print "getIntelStr(): IP to be checked is " + ip
            
        if (ip == ROUTER or ip == HPOT or ip == "ROUTER" or ip == "HPOT") :
            intelStr = "*,*,*"		# * = masked
        else :
            # Handle 192.168.1.131 used for testing
            #if line.find("192.168.1.") != -1 :
        
            #if ip == "0.0.0.0" :		# failed to extract IP from a record
            #    return "intell=0.0.0.0"
    
            # Get DNS info
            dnsInfo = ipintellib.ip2name(ip)
            dnsName = dnsInfo['name'].rstrip('.')			# right-strip the trailing .
        
            # WHOIS : primary information
            # Some confusion about which library to use for ip to AS info tranlsation
            #asInfo = rch_asn_funcs.ip2asn(ip)				# need to add routes=1 to get ASN - timeout bug at moment
            asInfo = ipintellib.ip2asn(ip)				# 
            asNum = asInfo['as']					# AS123 
            asRegisteredCode = asInfo['registeredCode']			# Short-form e.g.ARCOR
            #countryCode = asInfo['countryCode']			# Slower than GeoIP
            #print "getIntelStr(" + ip + ") : " + asNum + " " + asRegisteredCode
        
            # WHOIS info gathered from "infos" fields
            #info        = asInfo['info']
            #purpose     = asInfo['purpose']
            #vodafone    = asInfo['vodafone']
        
            # GeoIP information - faster than WHOIS for looking up Country Code information
            geoIP = ipintellib.geo_ip(ip)				
            countryCode = geoIP['countryCode']
            city        = geoIP['city']
            longitude   = geoIP['longitude']				# Used to calc approx. localtime
            latitude    = geoIP['latitude']				
            
            intelStr = countryCode + "," + asNum + "," + asRegisteredCode + "," + city + "," + dnsName + "," + "%.2f" % latitude + "N" + "," + "%.2f" % longitude + "E"
            #intelStr = countryCode + ",as,asc,ci,dns,lat,lon"
            
            # ,long=" + "%.2f" % float(longitude) 
            
        #print "getIntelStr(): result for " + ip + " is " + intelStr 
        return intelStr        

    except Exception,e:
        syslog.syslog("kojoney_tail.py : getIntelStr() exception caught = " + `e` + "ip=" + ip)
        return "intell=exception!"

def processSebek(line):
    try:
        line=line.strip("\n")
        #print line
        
        fields=line.split("=")
        #print fields
        cmdStr =  fields[1]
        
        pat="Host:(\d+.\d+.\d+.\d+)"
        ip=re.findall(pat,line)
        
        pat="CMD:(\w+)"
        cmd=re.findall(pat,line)
        
        pat="UID:(\d+)"
        uid=re.findall(pat,line)
        
        pat="PID:(\d+)"
        pid=re.findall(pat,line)
        
        geoIP = ipintellib.geo_ip(ip[0])				
        countryCode = geoIP['countryCode']
        print countryCode
            
        #print "processSebek() : ip=" + ip[0] + "CC=" + countryCode + " UID=" + uid[0] + " PID=" + pid[0] + " CMD=" + cmd[0] + " cmdStr=" + cmdStr
      
        writeSecVizSebek(uid[0],pid[0],ip[0],countryCode,cmd[0],cmdStr)
      
        #print "line is " + line
    except Exception,e:
        syslog.syslog("kojoney_tail.py : processSebek() exception caught = " + `e` + "line=" + line)
        



def processSSH(line):
    global PreviousIPs
    global CLInum
    global SessionId
    global Username
    
    if Username == None:
        Username = "_unknown_"
            
    try:
        #print "line read from file\n:" + line
        
        # haxx0r guessed password OK
        # Use this one to perform the ipintellib() functions
        if line.find("authenticated with password") != -1:
            SessionId = SessionId + 1
            
            fields=line.split(',')
            #print fields
            a = fields[2].split()
            ip = a[0].rstrip(']')
            Username = a[1]
            #print "a is " + `a`
        
            # Get DNS info
            dnsInfo = ipintellib.ip2name(ip)
            dnsName = dnsInfo['name']
        
            # WHOIS information
            asInfo = rch_asn_funcs.ip2asn(ip)
            #asNum = asInfo['as']				# AS123 
            asRegisteredCode = asInfo['registeredCode']		# Short-form e.g.ARCOR
        
            # GeoIP information
            geoIP = ipintellib.geo_ip(ip)
            countryCode = geoIP['countryCode']
            city        = geoIP['city']
            longitude   = geoIP['longitude']			# Used to calc approx. localtime
            
            #msg = "------------------------------------------------------------------------------------------" 
            #makeMsg(0,ip,msg)
            
            #if Username == 'root':
            #    msg = "cli,mars,W00T!,authOK,"   + Username + "," + countryCode + "," + asNum + "," + asRegisteredCode       
            #else:
            
            msg = "cli,mars,USER,authOK," + getIntelStr(ip,"-1") + "," + Username + "," + countryCode + "," + asRegisteredCode       
            makeMsg(0,ip,msg)
            
            # Write Security Visualisation Data to secViz file      
            print "Calling writeSecViz3()"
            writeSecViz3(ip,Username)
        
            # Compute localtime based on longitude
            locTime = calcLocalTime(longitude)
            msg = "cli,mars,INTEL," + getIntelStr(ip,"-1") + ",haxx0r localTime(est) is " + locTime      
            makeMsg(0,ip,msg)

            # Haxx0r's client stack information - using p0f 3.0.0, uptime is in seconds not hours
            #try:
            #    pass
                #p0fInfo = p0fcmd.getP0fInfo(ip,"0","172.31.0.67","22");
                #if p0fInfo['result'] == True:		# p0f data is available
                #    hops = p0fInfo['hops']
                #    os   = p0fInfo['genre']
                #    fw   = p0fInfo['firewall']
                #    nat  = p0fInfo['nat']
                #    if p0fInfo['genre'] == "Linux" :
                #        uptime = p0fInfo['uptime']	# measured in secs 
                #    else:
                #        uptime = 0
                #else:					# p0f data is not available
                #    hops   = 0        
                #    os     = "?"
                #    fw     = "?"
                #    nat    = "?"
                #    uptime = 0
               
                #p0fStr = "os=" + os + " hops=" + hops + " up=" + uptime + " fw=" + fw  + " NAT=" + nat 
                    
                # Compute haxx0r's PC bootTime based on p0f uptime (seconds)
                #bootTime = calcBootTime(uptime)
                #bootmsg = "haxx0r PC bootTime(est,UTC) is " + bootTime['timeStr']    

                # p0f info  
                #msg = "cli,mars,INTEL," + p0fStr	# INT = Intelligence      
                #makeMsg(0,ip,msg)
                
                # haxx0r boot time 
                #msg = "cli,mars,INTEL,bootTime," + bootmsg      
                #makeMsg(0,ip,msg)
                
                # Has this IP been seen before ?
                #if PreviousIPs.has_key(ip):			# IP has been seen before 
                #    msg = "cli,mars,INTEL,IP was last seen " + PreviousIPs[ip]['lastVisitStr'] + " with a bootTime of " + PreviousIPs[ip]['timeStr']
                #    makeMsg(0,ip,msg)
                    
                    # Has this PC stack been seen before ?
                    # i.e. are bootTimes within 30 minutes of each other ?
                #    if abs(float(PreviousIPs[ip]['epoch']) - float(bootTime['epoch'])) < 1800.0:
                #        msg = "cli,mars,INTEL,p0f uptime (secs) indicates repeat visit from haxx0r's PC from this ip"
                #        makeMsg(0,ip,msg)
                #else:
                #    PreviousIPs[ip] = bootTime			# set info to be haxx0r boottime    
                #    msg = "cli,mars,INTEL,first time visit from " + ip + ", user " + Username 
                #    makeMsg(0,ip,msg)       
                     
            #except Exception,e:
            #    syslog.syslog("Exception in processSSH() p0f for authOK section of code " + `e` + " ip=" + ip);
    
                
        # Extract haxxor's SSH client    
        elif line.find("pty request") != -1:
            fields=line.split(',')
            #print fields
            a = fields[2].split()
            #print "a is " + `a`
            ip = a[0].rstrip(']')
            pty = a[3]
            #print "pty is " + `pty`
            msg = "cli,mars,INTEL," + getIntelStr(ip,"-1") + ",event=client:" + pty 
            makeMsg(0,ip,msg)  
    
        # Disconnecting #1    
        elif line.find("sending close") != -1:
            fields=line.split(',')
            #print fields
            a = fields[2].split()
            ip = a[0].rstrip(']')
            #username = a[1]
            #print "a is " + `a`
            msg = "cli,mars,MISC," + getIntelStr(ip,"-1") + ",event=localClosed" 
            makeMsg(0,ip,msg) 
    
        # Disconnecting #2    
        elif line.find("remote close") != -1:
            fields=line.split(',')
            #print fields
            a = fields[2].split()
            ip = a[0].rstrip(']')
            #username = a[1]
            #print "a is " + `a`
            msg = "cli,mars,MISC," + getIntelStr(ip,"-1") + ",event=remoteClosed" 
            makeMsg(0,ip,msg) 
    
        # Request (OK or not OK) to download malware    
        elif line.find("Saved the file ") != -1:
            fields=line.split(',')
            print fields
            a = fields[2].split()
            ip = a[0].rstrip(']')
            fullFilename = a[4]
            fileName = os.path.basename(fullFilename)
        
            # GeoIP information
            geoIP = ipintellib.geo_ip(ip)
            countryCode = geoIP['countryCode']
        
            # Write Security Visualisation Data to secViz file      
            writeSecViz2(ip,Username,countryCode,fileName)
            
            # E-mail that the haxxor has downloaded a file        
            makeMsg(0,ip,"cli,mars,REINF,haxxorDownloadedFile")            
            alertBody = "Downloaded file :\n" + fileName
            #print "alertBody:\n" + alertBody 
   
            alert("Downloaded file",ip,Username,alertBody)
            
            # Send a Tweet
            sendTweetCLI(SessionId,Username,ip,cliInfoStr)
                      
        # haxx0r entered CLI command
        elif line.find("COMMAND IS") != -1:
            CLInum = CLInum + 1
        
            fields=line.split(',')
            # cliInfo = 
            a = fields[2].split()
            ip = a[0].rstrip(']')        
            #print "a is " + `a`
        
            cliInfo = a[4:]				# list containing CLI separated items - see backspaces
            cliInfoStr = " ".join(cliInfo)		# CLI as a single string
            clifInfoStr = '"' + cliInfoStr + '"'
            
            # Write to log file   
            if Username == 'root':
                msg = "USER_#," + cliInfoStr
            else:
                msg = "USER_$," + cliInfoStr
                 
            makeMsg(CLInum,ip,"cli,mars,INTEL," + msg) 
            
            # Send a Tweet
            sendTweetCLI(SessionId,Username,ip,cliInfoStr)
            
            if isHuman(cliInfo):
                makeMsg(CLInum,ip,"cli,mars,INTEL,humanHaxxor?")            
                alertBody = "haxx0r made a mistake typing the following :\n> " + cliInfoStr   
                alert("Human haxx0r online",ip,Username,alertBody)
        
            # Write Security Visualisation Data to secViz file
            geoIP = ipintellib.geo_ip(ip)
            countryCode = geoIP['countryCode']      
            writeSecViz1(ip,Username,countryCode,cliInfoStr)
                                                 
    except Exception,e:
        syslog.syslog("kojoney_tail.py exception : processSSH() : " + `e` + " ip=" + ip)
    
def genAmunSuffix():
    now = time.time()
    tuple = time.localtime(now)
    #filepath = "/usr/local/src/amun/logs/" + filename + "." + `tuple.tm_year` + "-" + "%02d" % tuple.tm_mon + "-" + "%02d" % tuple.tm_mday
    suffix = `tuple.tm_year` + "-" + "%02d" % tuple.tm_mon + "-" + "%02d" % tuple.tm_mday
    
    return suffix

# ----------- functions to be moved to external files ---
# Convert decimal logical OR of TCP flags to their flag names
# flags is an integer
def netflowFlags(flags):
    if flags == 0:
        return "X"
        
    flagsStr = ""
    if flags & 32 != 0 :
        flagsStr = flagsStr + "U"
    if flags & 16 != 0 :
        flagsStr = flagsStr + "A"
    if flags & 8 != 0 :
        flagsStr = flagsStr + "P"
    if flags & 4 != 0 :
        flagsStr = flagsStr + "R"
    if flags & 2 != 0 :
       flagsStr = flagsStr + "S"
    if flags & 1 != 0 :
       flagsStr = flagsStr + "F"
    
    #print "netflowFlags() result is " + flagsStr
    return flagsStr                                                                            

# x is an integer
def icmpDecode(x):
    type = int(x/256)
    code = x % 256   
    icmpStr = "T=" + `type` + ":C=" + `code`
    
    #print "icmpDecode() : result is " + icmpStr                
    return icmpStr
                           
# -------------------------------------------------------
        
# Start of code        
syslog.openlog("kojoney_flow")         # Set syslog program name         
       
# Make pidfile so we can be monitored by monit        
pid =  makePidFile("kojoney_tail")
if pid == None:
    syslog.syslog("Failed to create pidfile for pid " + `pid`)
    sys.exit(0)
else:
    syslog.syslog("kojoney_tail.py started with pid " + `pid`)
                
# Send an email to say kojoney_tail has started
now = time.time()
nowLocal = time.gmtime(now)
makeMsg(0,"0","system,kojoney_tail.py started with pid=" + `pid` + " at localtime " + time.asctime(nowLocal))
a = "kojoney_tail.py started with pid=" + `pid`

#statusAlert("*** kojoney_tail started ***",a)
    
# Set the Kojoney filename to scan
filename = '/home/var/log/kojoney.log'
file = open(filename,'r')
print "system     : Open Kojoney SSH log file : " + filename

# Set the Sebek filename to scan
filenameSebek = '/home/var/log/sebek.log.txt'
fileSebek = open(filenameSebek,'r')
print "system     : Open Sebek log file : " + filenameSebek

# Set the Snort filename to scan
filenameSnort = '/home/var/log/snort.syslog'
fileSnort = open(filenameSnort,'r')
print "system     : Open Snort log file : " + filenameSnort

# Set the Nepenthes filename to scan
filenameNep = '/home/var/nepenthes/nepenthes.log'
fileNep = open(filenameNep,'r')
print "system     : Open Nepenthes log file : " + filenameNep

#  
filenameMessages = '/var/log/messages'
fileMessages = open(filenameMessages,'r')
print "system     : Open log file : " + filenameMessages

# Set the fprobe Flows filename to scan
#filenameFlows = '/home/var/log/gloworm-ermin.mars_fp.netflows'
#fileFlows = open(filenameFlows,'r')

# Set the Border Gateway Flows filename to scan
# *** All netflows are written to this file
#filenameBGFlows = '/home/var/log/gloworm-ermin.bg_rtr.netflows'
#fileBGFlows = open(filenameBGFlows,'r')
filenameBGFlows = '/home/var/log/netflow_raw.syslog'
fileBGFlows = open(filenameBGFlows,'r')
print "system     : Open raw netflows log file : " + filenameBGFlows

# Set the Router honeypot filename to scan
#filenamerouter = '/home/var/log/gloworm-ermin.node9.netflows'
#filerouter = open(filenamerouter,'r')

# Set the iptables filename to scan
filenameFW = '/home/var/log/iptables.syslog'
fileFW = open(filenameFW,'r')
print "system     : Open iptables log file : " + filenameFW

# Set the ns5 filename (malware collection) to scan
filenameNS5 = '/home/var/log/ns5.syslog'
fileNS5 = open(filenameNS5,'r')
print "system     : Open NS5 log file : " + filenameNS5

# Set the ns5gt filename (high-interaction honeynet protection) to scan
filenameNS5GT = '/home/var/log/ns5gt.syslog'
fileNS5GT = open(filenameNS5GT,'r')
print "system     : Open NS5-GT log file : " + filenameNS5GT

# Set the p0f filename to scan
filenamep0f = '/home/var/log/p0f.log'
filep0f     = open(filenamep0f,'r')
print "system     : Open p0f log file : " + filenamep0f

# Set the Apache filename to scan
filenameWeb = '/home/var/log/httpd/error_log'
fileWeb     = open(filenameWeb,'r')
print "system     : Open Apache error log file : " + filenameWeb

# Set the Honeypot (Linux and Windows) DNS filename to scan
filenamedns = '/home/var/log/honeypot_dns.syslog'
filedns     = open(filenamedns,'r')
print "system     : Open Honeypots' DNS log file : " + filenamedns

# Set the AAA Authentication filename to scan
filenameaaa = '/home/var/log/tacacs.syslog'
fileaaa     = open(filenameaaa,'r')
print "system     : Open AAA authentication log file : " + filenameaaa

# Set the AAA Accounting filename to scan
filenameaaaa = '/var/log/tacacs.log'
fileaaaa     = open(filenameaaaa,'r')
print "system     : Open AAA accounting log file : " + filenameaaaa

# Set the router syslog filename to scan
filenamertr = '/home/var/log/router.syslog'
filertr     = open(filenamertr,'r')
print "system     : Open Router honeypot syslog file : " + filenamertr

# Set the PSAD syslog filename to scan
filenamepsad = '/home/var/log/psad.syslog'
filepsad     = open(filenamepsad,'r')
print "system     : Open PSAD log file : " + filenamepsad

# Set the Amun syslog filename to scan
filenameAmunsysDownload = '/home/var/log/amun.syslog'
fileAmunsysDownload = open(filenameAmunsysDownload,'r')
print "system     : Open AMUN log file #1 : " + filenameAmunsysDownload

# Set the Honeyd syslog filename to scan
filenameHoneydsys = '/home/var/log/honeyd.syslog'
fileHoneydsys = open(filenameHoneydsys,'r')
print "system     : Open Honeyd log file : " + filenameHoneydsys

# Set the Amun Download filename to scan
Today = genAmunSuffix()
filenameAmunDownload = '/usr/local/src/amun/logs/download.log'
fileAmunDownload = open(filenameAmunDownload,'r')
print "system     : Open AMUN log file #2 : " + filenameAmunDownload

# Set the Amun Submissions filename to scan
filenameAmunSubmit = '/usr/local/src/amun/logs/submissions.log'
fileAmunSubmit = open(filenameAmunSubmit,'r')
print "system     : Open AMUN submissions log file : " + filenameAmunSubmit

print " "

# ------------
# tail -f mode
# ------------

# Find the size of the SSH file and move to the end
st_results = os.stat(filename)
st_size = st_results[6]
file.seek(st_size)
print "system     : Seek to end of SSH feed"

# Find the size of the Sebek file and move to the end
st_results_sebek = os.stat(filenameSebek)
st_size_sebek = st_results_sebek[6]
fileSebek.seek(st_size_sebek)
print "system     : Seek to end of Sebek feed"

# Find the size of the Snort file and move to the end
st_results_snort = os.stat(filenameSnort)
st_size_snort = st_results_snort[6]
fileSnort.seek(st_size_snort)
print "system     : Seek to end of Snort IDS feed"

# Find the size of the Nepenthes file and move to the end
st_results_nep = os.stat(filenameNep)
st_size_nep = st_results_nep[6]
fileNep.seek(st_size_nep)
print "system     : Seek to end of Nepenthes honeypot feed"

# Find the size of the honeypot fprobe netflows file and move to the end
#st_results_flows = os.stat(filenameFlows)
#st_size_flows = st_results_flows[6]
#fileFlows.seek(st_size_flows)
#print "system     : Seek to end of ADSL router fprobe netflows feed"

# Find the size of the Border Gateway router netflows file and move to the end
st_results_bgflows = os.stat(filenameBGFlows)
st_size_bgflows = st_results_bgflows[6]
fileBGFlows.seek(st_size_bgflows)
print "system     : Seek to end of raw netflows feed"

# Find the size of the router honeypot netflows file and move to the end
#st_results_router = os.stat(filenamerouter)
#st_size_router = st_results_router[6]
#filerouter.seek(st_size_router)
#print "system     : Seek to end of router honeypot netflows feed"

# Find the size of the iptables file and move to the end
st_results_fw = os.stat(filenameFW)
st_size_fw = st_results_fw[6]
fileFW.seek(st_size_fw)
print "system     : Seek to end of iptables firewall logs feed"

# Find the size of the file and move to the end
st_results_NS5 = os.stat(filenameNS5)
st_size_NS5 = st_results_NS5[6]
fileNS5.seek(st_size_NS5)
print "system     : Seek to end of NS5 firewall logs feed"

# Find the size of the file and move to the end
st_results_NS5GT = os.stat(filenameNS5GT)
st_size_NS5GT = st_results_NS5GT[6]
fileNS5GT.seek(st_size_NS5GT)
print "system     : Seek to end of NS5-GT firewall logs feed"

# Find the size of the p0f file and move to the end
st_results_p0f = os.stat(filenamep0f)
st_size_p0f = st_results_p0f[6]
filep0f.seek(st_size_p0f)
print "system     : Seek to end of p0f feed"

# Find the size of the Web-server file and move to the end
st_results_Web = os.stat(filenameWeb)
st_size_Web = st_results_Web[6]
fileWeb.seek(st_size_Web)
print "system     : Seek to end of web apache feed"

# Find the size of the DNSMASQ file and move to the end
st_results_dns = os.stat(filenamedns)
st_size_dns = st_results_dns[6]
filedns.seek(st_size_dns)
print "system     : Seek to end of Malware host system dnsmasq DNS feed"

# Find the size of the AAA failed logins file and move to the end
st_results_aaa = os.stat(filenameaaa)
st_size_aaa = st_results_aaa[6]
fileaaa.seek(st_size_aaa)
print "system     : Seek to end of tac_plus router AAA Authentication feed"

# Find the size of the AAA accounting file and move to the end
st_results_aaaa = os.stat(filenameaaaa)
st_size_aaaa = st_results_aaaa[6]
fileaaaa.seek(st_size_aaaa)
print "system     : Seek to end of tac_plus router AAA Accounting feed"

# Find the size of the router syslog file and move to the end
st_results_rtr = os.stat(filenamertr)
st_size_rtr = st_results_rtr[6]
filertr.seek(st_size_rtr)
print "system     : Seek to end of router syslog feed"

# Find the size of the PSAD syslog file and move to the end
st_results_psad = os.stat(filenamepsad)
st_size_psad = st_results_psad[6]
filepsad.seek(st_size_psad)
print "system     : Seek to end of PSAD syslog feed"

# Find the size of the Amun Download file and move to the end
st_results_amunDownload = os.stat(filenameAmunDownload)
st_size_amunDownload = st_results_amunDownload[6]
fileAmunDownload.seek(st_size_amunDownload)
print "system     : Seek to end of AMUN malware collector download feed"

# Find the size of the Amun Syslog file and move to the end
st_results_amunsysDownload = os.stat(filenameAmunsysDownload)
st_size_amunsysDownload = st_results_amunsysDownload[6]
fileAmunsysDownload.seek(st_size_amunsysDownload)
print "system     : Seek to end of AMUN malware collector Syslog feed"

# Find the size of the Honeyd Syslog file and move to the end
st_results_honeydsys = os.stat(filenameHoneydsys)
st_size_honeydsys = st_results_honeydsys[6]
fileHoneydsys.seek(st_size_honeydsys)
print "system     : Seek to end of Honeyd honeypot Syslog feed"

# Find the size of the Amun Submissions file and move to the end
st_results_amunSubmit = os.stat(filenameAmunSubmit)
st_size_amunSubmit = st_results_amunSubmit[6]
fileAmunSubmit.seek(st_size_amunSubmit)
print "system     : Seek to end of AMUN malware collector submissions feed"

# Find the size of the /var/log/messages file and move to the end
st_results_messages = os.stat(filenameMessages)
st_size_messages = st_results_messages[6]
fileMessages.seek(st_size_messages)
print "system     : Seek to end of /var/log/messages feed"

print " "
print "Awaiting new events..."

while True:

    #today = genAmunSuffix()
    #if today != Today:		# Amun log file midnight rollover ?
    #    syslog.syslog("kojoney_tail.py : Amun logfile rolled over, re-open the file");
    #    time.sleep(120)		# Wait two minutes
    #    Today = today
        
        # Amun Download log file
    #    fileAmunDownload.close()
    #    fileAmunDownload = open(filenameAmunDownload,'r')
    #    st_results_amunDownload = os.stat(filenameAmunDownload)
    #    st_size_amunDownload = st_results_amunDownload[6]
    #    fileAmunDownload.seek(st_size_amunDownload)
        
        # Amun Submissions log file
    #    fileAmunSubmit.close()
    #    fileAmunSubmit = open(filenameAmunSubmit,'r')
    #    st_results_amunSubmit = os.stat(filenameAmunSubmit)
    #    st_size_amunSubmit = st_results_amunSubmit[6]
    #    fileAmunSubmit.seek(st_size_amunSubmit)
    
    # Kojoney        
    where = file.tell()
    line  = file.readline()
    
    # Sebek
    whereSebek = fileSebek.tell()
    lineSebek  = fileSebek.readline()
    
    # Snort
    whereSnort = fileSnort.tell()
    lineSnort  = fileSnort.readline()
    
    # Nepenthes
    whereNep = fileNep.tell()
    lineNep  = fileNep.readline()
    
    # Honeypot fprobe netflows
    #whereFlows = fileFlows.tell()
    #lineFlows  = fileFlows.readline()
    
    # Border Router netflows
    whereBGFlows = fileBGFlows.tell()
    lineBGFlows  = fileBGFlows.readline()
    
    # Router honeypot (node9) netflows
    #whererouter = filerouter.tell()
    #linerouter  = filerouter.readline()
    
    # Firewalls
    # iptables
    whereFW = fileFW.tell()
    lineFW  = fileFW.readline()
    # NetScreen NS5
    whereNS5 = fileNS5.tell()
    lineNS5  = fileNS5.readline()
    # NetScreen NS5-GT
    whereNS5GT = fileNS5GT.tell()
    lineNS5GT  = fileNS5GT.readline()
    
    # p0f
    wherep0f = filep0f.tell()
    linep0f  = filep0f.readline()
    
    # Web-server
    whereWeb = fileWeb.tell()
    lineWeb  = fileWeb.readline()
    
    # DNS - from DNSmasq used solely by Malware
    wheredns = filedns.tell()
    linedns  = filedns.readline()
    
    # AAA syslog - Authentication
    whereaaa = fileaaa.tell()
    lineaaa  = fileaaa.readline()
    
    # AAA syslog - Accounting
    whereaaaa = fileaaaa.tell()
    lineaaaa  = fileaaaa.readline()
    
    # router syslog - Accounting
    wherertr = filertr.tell()
    linertr  = filertr.readline()
    
    # PSAD syslog
    wherepsad = filepsad.tell()
    linepsad  = filepsad.readline()
    
    # Amun download.log
    whereAmunDownload = fileAmunDownload.tell()
    lineAmunDownload  = fileAmunDownload.readline()
    
    # Amun syslog 
    whereAmunsysDownload = fileAmunsysDownload.tell()
    lineAmunsysDownload  = fileAmunsysDownload.readline()
    
    # Honeyd syslog 
    whereHoneydsys = fileHoneydsys.tell()
    lineHoneydsys  = fileHoneydsys.readline()
    
    # /var/log/messages 
    whereMessages = fileMessages.tell()
    lineMessages  = fileMessages.readline()
    
    # sleep if nothing to do
    # todo : syntax error here
    #if (not line) and if (not lineSnort) and if (not lineFlows) :
    #    print "sleeping..."
    #    time.sleep(1)
    
    if not line:		# no data in kojoney.log
        #print "nothing in Kojoney logfile to process"
        file.seek(where)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in Kojoney logfile to process !"
        processSSH(line)
    
    #if not lineSebek:		# no data in Sebek log
        #print "nothing in Sebek logfile to process"
        #fileSebek.seek(whereSebek)
    #else:			# new data has been added to log file
        #print "\n*** NEW EVENT in Sebek to process"
    #    processSebek(lineSebek)
    
    if not lineSnort:		# no data in snort.syslog
        #print "nothing in Snort logfile to process"
        fileSnort.seek(whereSnort)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in Snort syslog to process"
        processSnort(lineSnort)
    
    if not lineNep:		# no data in snort.syslog
        #print "nothing in Nepenthes logfile to process"
        fileNep.seek(whereNep)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in Nepenthes log file to process"
        processNepenthes(lineNep)
            
    #if not lineFlows:		# no data in fprobe netflows log file
        #print "nothing in honeypot fprobe logfile to process"
    #    fileFlows.seek(whereFlows)
    #else:			# new data has been added to log file
    #    print "*** NEW EVENT in ADSL router raw netflow logfile to process !"
    #    processFlows(lineFlows)
    
    if not lineBGFlows:		# no data in Border Gateway netflows log file
        #print "nothing in Border Gateway router netflow logfile to process"
        fileBGFlows.seek(whereBGFlows)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in raw netflows (all sources) logfile to process !"
        processFlows(lineBGFlows)
    
    #if not linerouter:		# no data in honeypot router netflows log file
        #print "nothing in router honeypot netflow logfile to process"
    #    filerouter.seek(whererouter)
    #else:			# new data has been added to log file
        #print "*** NEW EVENT in router honeypot netflow logfile to process !"
    #    processFlows(linerouter)
    
    if not linepsad:		# no data in PSAD log file
        #print "nothing in PSAD logfile to process"
        filepsad.seek(wherepsad)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in PSAD logfile to process"
        processPSAD(linepsad)
    
    if not lineFW:		# iptables log contains IPS and firewall events
        #print "nothing in iptables syslog file to process"
        fileFW.seek(whereFW)
    elif lineFW.find("SID") != -1:
        print "\n*** NEW EVENT : IPS : event in iptables.syslog to process"
        processFWsnort(lineFW)
    # temporarily disabled whilst CPN IP SLA probe pings are present
    #else:
        #print "\n*** NEW EVENT : firewall : event in iptables.syslog to process"
        #processFW(lineFW)

    # NetScreen NS5
    if not lineNS5:		# no data 
        #print "nothing in NS5 logfile to process"
        fileNS5.seek(whereNS5)
    else:			# new data has been added to log file
        pass
        #print "\n*** NEW EVENT in NS5 logfile to process"
        #print lineNS5
        
    # NetScreen NS5-GT    
    if not lineNS5GT:		# no data 
        #print "nothing in NS5GT logfile to process"
        fileNS5GT.seek(whereNS5GT)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in NS5-GT logfile to process"
        print lineNS5GT
    
    # temporarily disabled         
    #if not linep0f:		# no data in p0f.log
        #print "nothing in p0f log file to process"
    #    filep0f.seek(wherep0f)
    #else:			# new data has been added to log file
        #print "*** NEW EVENT in p0f log file to process !"
    #    processp0f(linep0f)
    
    if not lineWeb:		# no data in Apache error log
        #print "nothing in Apache error log file to process"
        fileWeb.seek(whereWeb)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in Apache error log file to process"
        processWeb(lineWeb)
    
    if not linedns:		# no data in dnsmasq log
        #print "nothing in dnsmasq log file to process"
        filedns.seek(wheredns)
    else:			# new data has been added to log file
        print "*** NEW EVENT in dnsmasq log file to process !"
        processdns(linedns)
    
    # AAA Authentication
    if not lineaaa:		# no data in tacacs.syslog
        #print "nothing in AAA Authorisation log file to process"
        fileaaa.seek(whereaaa)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in AAA log file tacacs.syslog to process !"
        processaaa(lineaaa)
    
    # AAA Accounting
    if not lineaaaa:		# no data in tacacs.syslog
        #print "nothing in AAA Accounting log file to process"
        fileaaaa.seek(whereaaaa)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in AAA Accounting log file to process !"
        processaaaa(lineaaaa)
    
    # router syslog
    if not linertr:		# no data in router.syslog
        #print "nothing in router syslog file to process"
        filertr.seek(wherertr)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in router syslog file to process !"
        processrtr(linertr)
    
    if not lineAmunDownload:		# no data in Amun download.log
        #print "nothing in Amun download.log file to process"
        fileAmunDownload.seek(whereAmunDownload)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in Amun download file to process !"
        processAmunDownload(lineAmunDownload)
    
    # retired code 
    #if not lineAmunsysDownload:		# no data in Amun syslog
        #print "nothing in Amun syslog file to process"
    #    fileAmunsysDownload.seek(whereAmunsysDownload)
    #else:			# new data has been added to log file
    #    print "\n*** NEW EVENT in Amun syslog to process !"
    #    processAmunSyslog(lineAmunsysDownload)
    
    if not lineHoneydsys:		# no data in Honeyd syslog
        #print "nothing in Honeyd syslog file to process"
        fileHoneydsys.seek(whereHoneydsys)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in Honeyd syslog to process !"
        processHoneydSyslog(lineHoneydsys)
    
    if not lineMessages:		# no data in /var/log/messages
        #print "nothing in Amun syslog file to process"
        fileMessages.seek(whereMessages)
    else:			# new data has been added to log file
        print "\n*** NEW EVENT in /var/log/messages to process !"
        processMessages(lineMessages)
     
    #print "sleeping..."
    # this can be a float for sub-second sleep    
    time.sleep(0.1)	# 10th of a second
    
# ------------------
# batch process mode
# ------------------

#print "Run in batch mode"
#
#while True:
#    line = file.readline()
#    if not line : 
#        print "No data to read"
#        break
#    
#    process(line)
            
                                                                        